import _extends from "@babel/runtime/helpers/esm/extends";
import { useContext, useMemo } from 'react';
import { bindActionCreators } from '@frontegg/redux-store';
import { authActions, authStoreName } from '@frontegg/redux-store';
import { shallowEqual } from 'react-redux';
import { useSelector, useDispatch } from '../FronteggStoreContext';
import { ContextHolder } from '@frontegg/rest-api';
import { ShadowDomContext } from '../common';
const defaultMapper = {
  state: state => state,
  actions: actions => actions
};

/**
 * Use this `frontegg` hook function to obtain the complete authentication state, if it exists.
 *
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const { isAuthenticated, user } = useAuth();
 *
 *   return isAuthenticated ? <div>Hello, User {user.name}</div> : null;
 * }
 * ```
 *
 * You can also utilize other `frontegg` hooks like `useAuthUser` to specifically retrieve the user and redirect to the login page if necessary, `useAuthUserOrNull` to get the user if available, and `useIsAuthenticated` for checking authentication status.
 */

export function useAuth(stateMapper = defaultMapper.state) {
  return useSelector(state => stateMapper(state[authStoreName]), shallowEqual);
}

/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const { isAuthenticated, user } = useAuth();
 *   const loginWithRedirect = useLoginWithRedirect();
 *
 *   if (!isAuthenticated) {
 *     loginWithRedirect();
 *     return <></>;
 *   }
 *
 *   return (<div>Hello User {user.name}</div>);
 * }
 * ```
 *
 /**
 * Use this frontegg hook function to redirect the user to the login page when in hosted login mode.
 * If the user is already authenticated, this method will direct the user to the store, and you can retrieve user information using the `useAuthUserOrNull` method.
 *
 * To ensure the user is available on the first page load when authenticated, configure this option in your `FronteggProvider`:
 * `authOptions`:
 *   `hostedLoginOptions`:
 *     `loadUserOnFirstLoad: true`
 *
 * When using this option, you can have the user on the first load, and you can control when the user is redirected to the login page by using `loginWithRedirect`.
 */
export const useLoginWithRedirect = () => {
  const dispatch = useDispatch();
  return useMemo(() => bindActionCreators(authActions.requestHostedLoginAuthorize, dispatch), [authActions.requestHostedLoginAuthorize]);
};
export const useLoginWithRedirectV2 = () => {
  const dispatch = useDispatch();
  return useMemo(() => bindActionCreators(authActions.requestHostedLoginAuthorizeV2, dispatch), [authActions.requestHostedLoginAuthorizeV2]);
};
export const useAuthActions = () => {
  const dispatch = useDispatch();
  return useMemo(() => bindActionCreators(authActions, dispatch), [authActions]);
};
export const useOnRedirectTo = () => {
  var _context$onRedirectTo;
  const context = useContext(ShadowDomContext);
  return (_context$onRedirectTo = context == null ? void 0 : context.onRedirectTo) != null ? _context$onRedirectTo : ContextHolder.onRedirectTo;
};
export const useAuthRoutes = () => useAuth(state => _extends({}, state.routes));

/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const isAuthenticated  = useIsAuthenticated();
 *   return isAuthenticated ? <div>Hello User</div> : <Redirect to={'/login'}/>
 * }
 * ```
 *
 * use this frontegg hook function to get if user is "Authenticated"
 */
export const useIsAuthenticated = () => useSelector(({
  [authStoreName]: {
    isAuthenticated
  }
}) => isAuthenticated, shallowEqual);

/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const user = useAuthUser();
 *   return user ? <div>Hello {user.name}!</div> : <div>Hello Guest!</div>
 * }
 * ```
 *
 * Use this `frontegg` hook function to obtain the authenticated user. If the user is not authenticated, this method will immediately redirect the user to the login page. (Primarily intended for embedded mode usage)
 * To prevent this immediate redirection behavior, use the `useAuthUserOrNull` method.
 */
export const useAuthUser = () => {
  const {
    loginUrl,
    customLoginUrl
  } = useAuthRoutes();
  const onRedirectTo = useOnRedirectTo();
  const user = useAuthUserOrNull();
  const isSSR = typeof window === 'undefined';
  const noUser = {};
  if (user == null && !isSSR) {
    onRedirectTo(customLoginUrl != null ? customLoginUrl : loginUrl, {
      refresh: true
    });
    return noUser;
  }
  return user || noUser;
};

/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const user = useAuthUserOrNull();
 *   return user ? <div>Hello {user.name}!</div> : <div>Hello Guest!</div>
 * }
 * ```
 *
 * Use this `frontegg` hook function to retrieve the authenticated user. If the user is not authenticated, this hook will return null. To redirect the user to the login page in case they are not authenticated, use the `useAuthUser` method.
 */
export const useAuthUserOrNull = () => {
  const {
    user
  } = useSelector(({
    [authStoreName]: {
      user
    }
  }) => ({
    user
  }), shallowEqual);
  return user || null;
};

/**
 * hooks helpers
 */
export const sliceReducerActionsBy = reducer => {
  const reducerKeys = Object.keys(reducer);
  const reducerActions = reducerKeys.map(key => ({
    [key]: authActions[key]
  }));
  return reducerActions.reduce((p, n) => _extends({}, p, n), {});
};

/*
 * enableMapperFalsyReturnValue was added to be backward compatible with all usages
 * the scenario that require enableMapperFalsyReturnValue of true is when the
 * mapper function returns a falsy value then we want to return it as is - it's a valid case like in entitlements (when it's undefined)
 * IMO all usages should be like that
 */
export const stateHookGenerator = (stateMapper, subState, enableMapperFalsyReturnValue = false) => {
  return useSelector(state => {
    const mapperValue = stateMapper == null ? void 0 : stateMapper(state[authStoreName][subState]);
    if (enableMapperFalsyReturnValue && stateMapper) {
      return mapperValue;
    }
    return mapperValue != null ? mapperValue : state[authStoreName][subState];
  }, shallowEqual);
};
export const reducerActionsGenerator = (actions, reducers) => {
  const dispatch = useDispatch();
  return useMemo(() => bindActionCreators(_extends({}, actions, sliceReducerActionsBy(reducers)), dispatch), [dispatch]);
};