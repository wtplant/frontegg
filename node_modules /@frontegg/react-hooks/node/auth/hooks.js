"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stateHookGenerator = exports.sliceReducerActionsBy = exports.reducerActionsGenerator = void 0;
exports.useAuth = useAuth;
exports.useOnRedirectTo = exports.useLoginWithRedirectV2 = exports.useLoginWithRedirect = exports.useIsAuthenticated = exports.useAuthUserOrNull = exports.useAuthUser = exports.useAuthRoutes = exports.useAuthActions = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = require("react");
var _reduxStore = require("@frontegg/redux-store");
var _reactRedux = require("react-redux");
var _FronteggStoreContext = require("../FronteggStoreContext");
var _restApi = require("@frontegg/rest-api");
var _common = require("../common");
const defaultMapper = {
  state: state => state,
  actions: actions => actions
};

/**
 * Use this `frontegg` hook function to obtain the complete authentication state, if it exists.
 *
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const { isAuthenticated, user } = useAuth();
 *
 *   return isAuthenticated ? <div>Hello, User {user.name}</div> : null;
 * }
 * ```
 *
 * You can also utilize other `frontegg` hooks like `useAuthUser` to specifically retrieve the user and redirect to the login page if necessary, `useAuthUserOrNull` to get the user if available, and `useIsAuthenticated` for checking authentication status.
 */

function useAuth(stateMapper = defaultMapper.state) {
  return (0, _FronteggStoreContext.useSelector)(state => stateMapper(state[_reduxStore.authStoreName]), _reactRedux.shallowEqual);
}

/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const { isAuthenticated, user } = useAuth();
 *   const loginWithRedirect = useLoginWithRedirect();
 *
 *   if (!isAuthenticated) {
 *     loginWithRedirect();
 *     return <></>;
 *   }
 *
 *   return (<div>Hello User {user.name}</div>);
 * }
 * ```
 *
 /**
 * Use this frontegg hook function to redirect the user to the login page when in hosted login mode.
 * If the user is already authenticated, this method will direct the user to the store, and you can retrieve user information using the `useAuthUserOrNull` method.
 *
 * To ensure the user is available on the first page load when authenticated, configure this option in your `FronteggProvider`:
 * `authOptions`:
 *   `hostedLoginOptions`:
 *     `loadUserOnFirstLoad: true`
 *
 * When using this option, you can have the user on the first load, and you can control when the user is redirected to the login page by using `loginWithRedirect`.
 */
const useLoginWithRedirect = () => {
  const dispatch = (0, _FronteggStoreContext.useDispatch)();
  return (0, _react.useMemo)(() => (0, _reduxStore.bindActionCreators)(_reduxStore.authActions.requestHostedLoginAuthorize, dispatch), [_reduxStore.authActions.requestHostedLoginAuthorize]);
};
exports.useLoginWithRedirect = useLoginWithRedirect;
const useLoginWithRedirectV2 = () => {
  const dispatch = (0, _FronteggStoreContext.useDispatch)();
  return (0, _react.useMemo)(() => (0, _reduxStore.bindActionCreators)(_reduxStore.authActions.requestHostedLoginAuthorizeV2, dispatch), [_reduxStore.authActions.requestHostedLoginAuthorizeV2]);
};
exports.useLoginWithRedirectV2 = useLoginWithRedirectV2;
const useAuthActions = () => {
  const dispatch = (0, _FronteggStoreContext.useDispatch)();
  return (0, _react.useMemo)(() => (0, _reduxStore.bindActionCreators)(_reduxStore.authActions, dispatch), [_reduxStore.authActions]);
};
exports.useAuthActions = useAuthActions;
const useOnRedirectTo = () => {
  var _context$onRedirectTo;
  const context = (0, _react.useContext)(_common.ShadowDomContext);
  return (_context$onRedirectTo = context == null ? void 0 : context.onRedirectTo) != null ? _context$onRedirectTo : _restApi.ContextHolder.onRedirectTo;
};
exports.useOnRedirectTo = useOnRedirectTo;
const useAuthRoutes = () => useAuth(state => (0, _extends2.default)({}, state.routes));

/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const isAuthenticated  = useIsAuthenticated();
 *   return isAuthenticated ? <div>Hello User</div> : <Redirect to={'/login'}/>
 * }
 * ```
 *
 * use this frontegg hook function to get if user is "Authenticated"
 */
exports.useAuthRoutes = useAuthRoutes;
const useIsAuthenticated = () => (0, _FronteggStoreContext.useSelector)(({
  [_reduxStore.authStoreName]: {
    isAuthenticated
  }
}) => isAuthenticated, _reactRedux.shallowEqual);

/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const user = useAuthUser();
 *   return user ? <div>Hello {user.name}!</div> : <div>Hello Guest!</div>
 * }
 * ```
 *
 * Use this `frontegg` hook function to obtain the authenticated user. If the user is not authenticated, this method will immediately redirect the user to the login page. (Primarily intended for embedded mode usage)
 * To prevent this immediate redirection behavior, use the `useAuthUserOrNull` method.
 */
exports.useIsAuthenticated = useIsAuthenticated;
const useAuthUser = () => {
  const {
    loginUrl,
    customLoginUrl
  } = useAuthRoutes();
  const onRedirectTo = useOnRedirectTo();
  const user = useAuthUserOrNull();
  const isSSR = typeof window === 'undefined';
  const noUser = {};
  if (user == null && !isSSR) {
    onRedirectTo(customLoginUrl != null ? customLoginUrl : loginUrl, {
      refresh: true
    });
    return noUser;
  }
  return user || noUser;
};

/**
 * ```jsx
 * export const MyFunctionComponent = () => {
 *   const user = useAuthUserOrNull();
 *   return user ? <div>Hello {user.name}!</div> : <div>Hello Guest!</div>
 * }
 * ```
 *
 * Use this `frontegg` hook function to retrieve the authenticated user. If the user is not authenticated, this hook will return null. To redirect the user to the login page in case they are not authenticated, use the `useAuthUser` method.
 */
exports.useAuthUser = useAuthUser;
const useAuthUserOrNull = () => {
  const {
    user
  } = (0, _FronteggStoreContext.useSelector)(({
    [_reduxStore.authStoreName]: {
      user
    }
  }) => ({
    user
  }), _reactRedux.shallowEqual);
  return user || null;
};

/**
 * hooks helpers
 */
exports.useAuthUserOrNull = useAuthUserOrNull;
const sliceReducerActionsBy = reducer => {
  const reducerKeys = Object.keys(reducer);
  const reducerActions = reducerKeys.map(key => ({
    [key]: _reduxStore.authActions[key]
  }));
  return reducerActions.reduce((p, n) => (0, _extends2.default)({}, p, n), {});
};

/*
 * enableMapperFalsyReturnValue was added to be backward compatible with all usages
 * the scenario that require enableMapperFalsyReturnValue of true is when the
 * mapper function returns a falsy value then we want to return it as is - it's a valid case like in entitlements (when it's undefined)
 * IMO all usages should be like that
 */
exports.sliceReducerActionsBy = sliceReducerActionsBy;
const stateHookGenerator = (stateMapper, subState, enableMapperFalsyReturnValue = false) => {
  return (0, _FronteggStoreContext.useSelector)(state => {
    const mapperValue = stateMapper == null ? void 0 : stateMapper(state[_reduxStore.authStoreName][subState]);
    if (enableMapperFalsyReturnValue && stateMapper) {
      return mapperValue;
    }
    return mapperValue != null ? mapperValue : state[_reduxStore.authStoreName][subState];
  }, _reactRedux.shallowEqual);
};
exports.stateHookGenerator = stateHookGenerator;
const reducerActionsGenerator = (actions, reducers) => {
  const dispatch = (0, _FronteggStoreContext.useDispatch)();
  return (0, _react.useMemo)(() => (0, _reduxStore.bindActionCreators)((0, _extends2.default)({}, actions, sliceReducerActionsBy(reducers)), dispatch), [dispatch]);
};
exports.reducerActionsGenerator = reducerActionsGenerator;