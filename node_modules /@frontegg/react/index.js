'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var js = require('@frontegg/js');
var reactHooks = require('@frontegg/react-hooks');
var ReactRouterDom = require('react-router-dom');
var restApi = require('@frontegg/rest-api');
var AppHolder = require('@frontegg/js/AppHolder');
var reduxStore = require('@frontegg/redux-store');
var ReactPkg = _interopDefault(require('react/package.json'));
var types = require('@frontegg/types');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

var BrowserRouter = ReactRouterDom.BrowserRouter;
var useHistory = function () {
    var _a, _b, _c;
    // @ts-ignore
    var navigate = ((_a = ReactRouterDom.useInRouterContext) === null || _a === void 0 ? void 0 : _a.call(ReactRouterDom)) ? (_b = ReactRouterDom.useNavigate) === null || _b === void 0 ? void 0 : _b.call(ReactRouterDom) : null;
    var history = (_c = ReactRouterDom.useHistory) === null || _c === void 0 ? void 0 : _c.call(ReactRouterDom);
    if (navigate) {
        var push = function (path, state) {
            if (state) {
                navigate(path, { state: state });
            }
            else {
                navigate(path);
            }
        };
        var replace = function (path, state) {
            navigate(path, { state: state, replace: true });
        };
        return { push: push, replace: replace };
    }
    return history;
};

var sdkVersion = { version: '6.0.28' };

var removeRedirectUrlFromQuery = function (query) {
    var q = new URLSearchParams(query);
    q.delete('redirectUrl');
    return q.toString();
};
var useQueryKeeper = function (_a) {
    var routes = _a.routes, history = _a.history;
    var queryParams = React.useRef();
    var prevPathname = React.useRef();
    var _b = ReactRouterDom.useLocation(), pathname = _b.pathname, search = _b.search;
    React.useEffect(function () {
        if (!!search) {
            queryParams.current = search;
            prevPathname.current = pathname;
        }
    }, []);
    React.useEffect(function () {
        var shouldKeepQuery = !!Object.values(routes).find(function (route) { return route === prevPathname.current; });
        if (!search && !!queryParams.current && shouldKeepQuery) {
            var query = removeRedirectUrlFromQuery(queryParams.current);
            history.push(pathname + ("?" + query));
        }
        prevPathname.current = pathname;
    }, [pathname, search, routes]);
};

var QueryKeeperWrapper = function (_a) {
    var history = _a.history;
    var signUpUrl = reactHooks.useAuthRoutes().signUpUrl;
    useQueryKeeper({ routes: { signUpUrl: signUpUrl }, history: history });
    return React__default.createElement(React__default.Fragment, null);
};
var AlwaysRenderInProvider = function (_a) {
    var isExternalHistory = _a.isExternalHistory, app = _a.app, themeOptions = _a.themeOptions, history = _a.history;
    return (React__default.createElement(React__default.Fragment, null,
        React__default.createElement(reactHooks.CustomComponentRegister, { app: app, themeOptions: themeOptions }),
        !isExternalHistory && React__default.createElement(QueryKeeperWrapper, { history: history })));
};

var ConnectorHistory = function (props) {
    var history = useHistory();
    return React__default.createElement(Connector, __assign({ history: history }, props));
};
/**
 * @param path path to check
 * @param routes frontegg auth routes
 * @returns true when should bypass react router
 */
function isBypassReactRoute(path, routes) {
    var stepUpUrl = (routes === null || routes === void 0 ? void 0 : routes.stepUpUrl) || reduxStore.defaultFronteggRoutes.stepUpUrl;
    return stepUpUrl && path.startsWith(stepUpUrl);
}
var Connector = function (_a) {
    var _b, _c;
    var history = _a.history, appName = _a.appName, _d = _a.isExternalHistory, isExternalHistory = _d === void 0 ? false : _d, props = __rest(_a, ["history", "appName", "isExternalHistory"]);
    var isSSR = typeof window === 'undefined';
    var version = "@frontegg/react@" + sdkVersion.version;
    // v6 or v5
    var baseName = (_b = props.basename) !== null && _b !== void 0 ? _b : '';
    var isAuthRouteRef = React.useRef(function () { return false; });
    React.useEffect(function () {
        isAuthRouteRef.current = function (path) { var _a; return reduxStore.isAuthRoute(path, (_a = props.authOptions) === null || _a === void 0 ? void 0 : _a.routes); };
    }, [(_c = props.authOptions) === null || _c === void 0 ? void 0 : _c.routes]);
    var onRedirectTo = React.useCallback(function (_path, opts) {
        var _a, _b;
        var path = _path;
        // noinspection SuspiciousTypeOfGuard
        if (baseName && typeof baseName === 'string' && baseName.length > 0 && path.startsWith(baseName)) {
            path = path.substring(baseName.length);
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.preserveQueryParams) || isAuthRouteRef.current(path)) {
            path = "" + path + window.location.search;
        }
        if (isBypassReactRoute(path, (_a = props.authOptions) === null || _a === void 0 ? void 0 : _a.routes)) {
            // when user app includes a fallback route, we need to avoid using the react router
            (_b = window === null || window === void 0 ? void 0 : window.history) === null || _b === void 0 ? void 0 : _b.pushState(null, '', path);
            return;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.refresh) && !isSSR) {
            // @ts-ignore
            window.Cypress ? history.push(path) : (window.location.href = path);
        }
        else {
            (opts === null || opts === void 0 ? void 0 : opts.replace) ? history.replace(path) : history.push(path);
        }
    }, []);
    var app = React.useMemo(function () {
        var _a;
        try {
            return AppHolder.AppHolder.getInstance(appName !== null && appName !== void 0 ? appName : 'default');
        }
        catch (e) {
            return js.initialize(__assign(__assign({}, props), { basename: (_a = props.basename) !== null && _a !== void 0 ? _a : baseName, contextOptions: __assign({ requestCredentials: 'include', metadataHeaders: {
                        //TODO: remove this ts-ignore after updating rest-api context options type to accept string.
                        //@ts-ignore
                        framework: restApi.FronteggFrameworks.React + "@" + ReactPkg.version,
                        fronteggSdkVersion: version,
                    } }, props.contextOptions), onRedirectTo: onRedirectTo }), appName !== null && appName !== void 0 ? appName : 'default');
        }
    }, []);
    restApi.ContextHolder.setOnRedirectTo(onRedirectTo);
    return (React__default.createElement(reactHooks.FronteggStoreProvider, __assign({}, __assign(__assign({}, props), { app: app }), { alwaysVisibleChildren: React__default.createElement(AlwaysRenderInProvider, { app: app, themeOptions: props.themeOptions, history: history, isExternalHistory: isExternalHistory }) })));
};
var FronteggProvider = function (props) {
    var history = useHistory();
    if (props.history || history) {
        return (React__default.createElement(Connector, __assign({ history: props.history || history, isExternalHistory: !!props.history }, props), props.children));
    }
    return (React__default.createElement(BrowserRouter, { basename: props.basename },
        React__default.createElement(ConnectorHistory, __assign({}, props), props.children)));
};

var AuthorizedContent = function (props) {
    var _a, _b;
    var isAuthorized = true; // Initially
    var user = reactHooks.useAuthUserOrNull();
    if (!(user === null || user === void 0 ? void 0 : user.superUser)) {
        if (props.requiredPermissions) {
            isAuthorized = false; // Reset - we are going to check that the user has at least one matching permission
            var _loop_1 = function (permission) {
                if ((_a = user === null || user === void 0 ? void 0 : user.permissions) === null || _a === void 0 ? void 0 : _a.find(function (_a) {
                    var key = _a.key;
                    return key === permission;
                })) {
                    isAuthorized = true;
                }
            };
            for (var _i = 0, _c = props.requiredPermissions; _i < _c.length; _i++) {
                var permission = _c[_i];
                _loop_1(permission);
            }
        }
        if (props.requiredRoles) {
            isAuthorized = false; // Reset - we are going to check that the user has at least one matching role
            var _loop_2 = function (role) {
                if ((_b = user === null || user === void 0 ? void 0 : user.roles) === null || _b === void 0 ? void 0 : _b.find(function (_a) {
                    var key = _a.key;
                    return key === role;
                })) {
                    isAuthorized = true;
                }
            };
            for (var _d = 0, _e = props.requiredRoles; _d < _e.length; _d++) {
                var role = _e[_d];
                _loop_2(role);
            }
        }
    }
    if (typeof props.render === 'function') {
        return React__default.createElement(React__default.Fragment, null, props.render(isAuthorized));
    }
    return isAuthorized ? React__default.createElement(React__default.Fragment, null, props.children) : null;
};

var useCheckoutDialog = function (appName) {
    if (appName === void 0) { appName = 'default'; }
    var _a = React.useState({
        open: false,
        error: null,
        success: false,
    }), _b = _a[0], open = _b.open, error = _b.error, success = _b.success, setState = _a[1];
    var handleError = React.useCallback(function (error) {
        setState({
            open: true,
            success: false,
            error: error,
        });
    }, []);
    var handleSuccess = React.useCallback(function () {
        setState({
            open: false,
            success: true,
            error: null,
        });
    }, []);
    var showDialog = React.useCallback(function (plan) {
        js.CheckoutDialog.show({
            plan: plan,
            onClose: hideDialog,
            onError: handleError,
            onSuccess: handleSuccess,
        }, appName);
        setState({
            open: true,
            success: false,
            error: null,
        });
    }, [appName]);
    var hideDialog = React.useCallback(function () {
        js.CheckoutDialog.hide(appName);
        setState({
            open: false,
            error: null,
            success: false,
        });
    }, [appName]);
    return React.useMemo(function () { return ({
        open: open,
        showDialog: showDialog,
        hideDialog: hideDialog,
        error: error,
        success: success,
    }); }, [open, showDialog, hideDialog, error, success]);
};

/**
 * Stepped up content component that shows the wrapped content only when the user is stepped up
 * The component triggers the step up flow if the user is not stepped up
 * @param props.maxAge maximum time in second that the login is valid
 * @param props.preventSteppingUp true when the step up flow should not be triggered automatically when the user is not stepped up, default to false
 * @param props.render render function to be called when user is stepped up
 * @param props.children to be shown when user is stepped up (only if render not provided)
 *
 * Pay attention, when shouldTriggerStepUp is true, two instances of SteppedUpContent can be rendered in the same page on the same render cycle.
 */
var SteppedUpContent = function (props) {
    var isAuthenticated = reactHooks.useIsAuthenticated();
    if (!isAuthenticated)
        return null;
    return React__default.createElement(SteppedUpContentInternal, __assign({}, props));
};
var SteppedUpContentInternal = function (_a) {
    var maxAge = _a.maxAge, preventSteppingUp = _a.preventSteppingUp, render = _a.render, children = _a.children;
    var isSteppedUp = reactHooks.useIsSteppedUp({ maxAge: maxAge });
    var stepUp = reactHooks.useStepUp();
    var isStepUpCalled = React.useRef(false);
    React.useEffect(function () {
        if (isSteppedUp) {
            isStepUpCalled.current = false;
            return;
        }
        if (isStepUpCalled.current)
            return;
        if (!preventSteppingUp) {
            stepUp({ maxAge: maxAge });
        }
        isStepUpCalled.current = true;
    }, [isSteppedUp, maxAge, preventSteppingUp, stepUp]);
    if (typeof render === 'function') {
        return React__default.createElement(React__default.Fragment, null, render(isSteppedUp));
    }
    return isSteppedUp ? React__default.createElement(React__default.Fragment, null, children) : null;
};

Object.keys(reactHooks).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return reactHooks[k];
        }
    });
});
Object.keys(types).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return types[k];
        }
    });
});
Object.defineProperty(exports, 'AdminPortal', {
    enumerable: true,
    get: function () {
        return js.AdminPortal;
    }
});
Object.defineProperty(exports, 'CheckoutDialog', {
    enumerable: true,
    get: function () {
        return js.CheckoutDialog;
    }
});
Object.defineProperty(exports, 'HostedLogin', {
    enumerable: true,
    get: function () {
        return js.HostedLogin;
    }
});
Object.defineProperty(exports, 'ContextHolder', {
    enumerable: true,
    get: function () {
        return restApi.ContextHolder;
    }
});
exports.AuthorizedContent = AuthorizedContent;
exports.Connector = Connector;
exports.ConnectorHistory = ConnectorHistory;
exports.FronteggProvider = FronteggProvider;
exports.SteppedUpContent = SteppedUpContent;
exports.useCheckoutDialog = useCheckoutDialog;
//# sourceMappingURL=index.js.map
