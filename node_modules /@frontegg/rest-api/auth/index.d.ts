export * from "./secutiry-poilicy";
export * from "./enums";
export { setTabTenantInSessionStorage, getTabTenantFromSessionStorage, getCurrentUserTenantsFunction } from './utils';
import { ISamlRolesGroup } from "../teams/interfaces";
import { IAcceptInvitation, IActivateAccount, IAllowedToRememberMfaDevice, ICreateSamlGroup, IDeleteApiToken, IDisableMfa, IEnrollMfaResponse, IForgotPassword, IGetActivateAccountStrategy, IGetActivateAccountStrategyResponse, IGetUserById, IGetUserPasswordConfig, ILogin, ILoginResponse, ILoginViaSocialLogin, ILoginViaSocialLoginResponse, ILoginWithMfa, IOidcPostLogin, IOidcConfiguration, IPostLogin, IPreLogin, IRecoverMFAToken, IResendActivationEmail, IResetPassword, ISamlConfiguration, ISamlVendorConfigResponse, ISignUpResponse, ISignUpUser, ISocialLoginProviderConfiguration, ITenantApiTokensData, IUpdateSamlConfiguration, IUpdateSamlGroup, IUpdateSamlRoles, IUpdateSamlVendorMetadata, IUpdateTenantApiTokensData, IUpdateUserApiTokensData, IUserApiTokensData, IUserIdResponse, IVendorConfig, IVerifyMfa, IVerifyMfaResponse, TestConfig, ISSOPublicConfiguration, IPreLoginWithIdpTypeResponse, IPasswordlessPreLogin, IPasswordlessPostLogin, ICreateSSODomain, IVerifyInviteToken, ISSODomain, ISSOConfigurationDefaultRoles, ISSOConfiguration, IUpdateSSOConfiguration, IOidcPostLoginV2, IExchangeOAuthTokens, IOAuthTokenResponse, ISocialLoginProviderConfigurationV2, ILoginResponseV2, IResetPhoneNumber, IVerifyResetPhoneNumber, IChangePhoneNumber, IVerifyResetPhoneNumberResponse, IResetPhoneNumberResponse, IWebAuthnPreLogin, IWebAuthnPostLogin, IVerifyNewWebAuthnDevice, IWebAuthnPreLoginResponse, ICreateNewDeviceSessionResponse, IAuthStrategiesConfig, ISessionResponse, IChangePhoneNumberWithVerification, IChangePhoneNumberWithVerificationResponse, IVerifyChangePhoneNumber, ISessionConfigurations, IResendInvitationEmail, IPreEnrollMFA, IEnrollMFAAuthenticatorApp, IPreEnrollMFASMS, IEnrollMFASMS, IEnrollMFAWebAuthn, IPreEnrollMFAAuthenticatorAppResponse, IPreEnrollMFAWebAuthnResponse, IVerifyMFAAuthenticatorApp, IPreVerifyMFA, IPreVerifyMFASMSResponse, IVerifyMFASMS, IPreVerifyMFAWebAuthnResponse, IVerifyMFAWebAuthn, IPreEnrollMFASMSResponse, IPreDisableMFASMSResponse, IDisableMFASMS, IDisableMFAWebAuthn, IPreDisableMFAWebAuthnResponse, UserMFADevicesResponse, WithoutMFAToken, IMFAStrategiesResponse, IOAuthLogout, IGetUserAccessTokens, IGetTenantAccessTokens, IDeleteAccessToken, ICreateTenantAccessTokenData, ICreateUserAccessTokenData, IWebAuthnDevices, ICustomSocialLoginProviderConfigurationV1, ILoginResponseV3, IPreVerifyMFAEmailCodeResponse, IVerifyMFAEmailCode, ICreateOrUpdateSSOConfigurationByMetadataUrl, GenerateStepUpRequest, GenerateStepUpResponse } from './interfaces';
import { IGetUserAuthorizationResponse, IUserProfile } from "../users/interfaces";
/*****************************************
 * Authentication
 *****************************************/
export declare function generateLoginResponse(loginResponse: ILoginResponse): Promise<ILoginResponse>;
export declare function generateLoginResponseV2(loginResponse: ILoginResponse): Promise<ILoginResponseV2>;
export declare function generateLoginResponseV3(loginResponse: ILoginResponse): Promise<ILoginResponseV3>;
export declare function generateLoginResponseFromOAuthResponse(oauthResponse: IOAuthTokenResponse): Promise<ILoginResponse>;
export declare function generateLoginResponseFromOAuthResponseV2(oauthResponse: IOAuthTokenResponse): Promise<ILoginResponseV3>;
/**
 * Check if requested email address has sso configuration
 * If true, this function will return the sso address to navigate to
 * else, return null
 */
export declare function preLogin(body: IPreLogin): Promise<string | null>;
/**
 * Check if requested email address has sso configuration
 * If true, this function will return the sso address and IdpType to navigate to
 */
export declare function preLoginWithIdpType(body: IPreLogin): Promise<IPreLoginWithIdpTypeResponse | null>;
/**
 * After calling preLogin and navigated to SSO url, the IDP will redirect you to the ACS Url
 * Which configured in the SSO configuraation
 * else, return null
 */
export declare function postLogin(body: IPostLogin): Promise<ILoginResponse>;
/**
 * After calling preLogin and navigated to SSO url, the IDP will redirect you to the redirect url
 * with code and state
 */
export declare function oidcPostLogin(body: IOidcPostLogin): Promise<ILoginResponse>;
/**
 * login with username and password.
 * if the user has two factor authentication
 *    the server will return mfaToken with mfaRequired: true,
 *    and then ``loginWithMfa`` should be called with the mfaToken and and generated code
 * else, the server will accessToken and refreshToken.
 * the refresh should be used to renew your access token by calling ``refreshToken``
 *
 * @throw exception if login failed
 */
export declare function login(body: ILogin): Promise<ILoginResponse>;
/**
 * login with username and password.
 * if the user has two factor authentication
 *    the server will return mfaToken with mfaRequired: true,
 *    and then ``loginWithMfa`` should be called with the mfaToken and and generated code
 * else, the server will accessToken and refreshToken.
 * the refresh should be used to renew your access token by calling ``refreshToken``
 *
 * @throw exception if login failed
 */
export declare function loginv2(body: ILogin): Promise<ILoginResponseV3>;
/**
 * after login succeeded with mfaRequired token response, this function should be called
 * with the mfaToken and the generated code from your authenticator app.
 *
 * @throw exception if generated code or mfaToken are incorrect
 */
export declare function loginWithMfa(body: ILoginWithMfa): Promise<ILoginResponse>;
/**
 * after login succeeded with mfaRequired token response, this function should be called
 * with the mfaToken and the generated code from your authenticator app.
 *
 * @throw exception if generated code or mfaToken are incorrect
 */
export declare function loginWithMfaV2(body: ILoginWithMfa): Promise<ILoginResponseV3>;
/**
 * activating account should be called after registering new user of deactivate account
 * ``activateAccount`` should contains userId and the token that has been sent to the user after activation requested.
 *
 * @throws exception if activation failed
 */
export declare function activateAccount(body: IActivateAccount): Promise<void>;
/**
 * activating account should be called after registering new user of deactivate account
 * ``activateAccount`` should contains userId and the token that has been sent to the user after activation requested.
 *
 * @throws exception if activation failed
 */
export declare function activateAccountV2(body: IActivateAccount): Promise<ILoginResponseV3>;
/**
 * get account activation configuration.
 */
export declare function getActivateAccountStrategy(params: IGetActivateAccountStrategy): Promise<IGetActivateAccountStrategyResponse>;
/**
 * resend activation email should be called after a failed user activation.
 * ``resend activation email`` should contain  the user email.
 *
 * @throws exception if resend failed
 */
export declare function resendActivationEmail(body: IResendActivationEmail): Promise<void>;
/**
 * resend invitation email should be called after a failed user invitation.
 * ``resend invitation email`` should contain  the user email.
 *
 * @throws exception if resend failed
 */
export declare function resendInvitationEmail(body: IResendInvitationEmail): Promise<void>;
/**
 * activating account should be called after registering new user of deactivate account
 * ``activateAccount`` should contains userId and the token that has been sent to the user after activation requested.
 *
 * @throws exception if activation failed
 */
export declare function acceptInvitation(body: IAcceptInvitation): Promise<void>;
/**
 * refresh token called as authenticated use, access and refresh tokens resolved by the cookies.
 * the server will return ILoginResponse with new access Token and refresh token and store it in the browser cookies.
 */
export declare function refreshToken(): Promise<ILoginResponse>;
/**
 * refresh token called as authenticated use, access and refresh tokens resolved by the cookies.
 * the server will return ILoginResponseV2 with new access Token and refresh token and store it in the browser cookies, as well as the tenants.
 */
export declare function refreshTokenV2(): Promise<ILoginResponseV2>;
/**
 * refresh token called as authenticated use, access and refresh tokens resolved by the cookies.
 * the server will return ILoginResponseV3 with new access Token and refresh token and store it in the browser cookies, as well as the tenants and the active tenant.
 */
export declare function refreshTokenV3(): Promise<ILoginResponseV3>;
/**
 * logout from server, invalidate access and refresh token, remove it from cookies.
 */
export declare function logout(): Promise<void>;
/**
 * logout from server on Hosted Login, invalidate access and refresh token, remove it from cookies.
 */
export declare function OAuthLogout(params?: IOAuthLogout): Promise<void>;
/**
 * calling forgot password request will send email with link to reset user's password.
 *
 * @throws exception if the user not found
 */
export declare function forgotPassword(body: IForgotPassword): Promise<void>;
/**
 * reset password should be called after forget password request.
 * userId, new password and the token has been sent to the user email.
 *
 * @throws exception if the user not found, password validation failed or invalid token.
 */
export declare function resetPassword(body: IResetPassword): Promise<void>;
/**
 * load password configuration for user.
 */
export declare function loadPasswordConfig(params?: IGetUserPasswordConfig): Promise<Partial<TestConfig> | null>;
/**
 * recover Multi-Factor authentication by providing the recoveryCode
 * that has been received when activated it
 *
 * @throws exception if recovery code is not valid
 */
export declare function recoverMfaToken(body: IRecoverMFAToken): Promise<void>;
/**
 * Multi-Factor Settings
 */
/**
 * enroll Multi-Factor Auth Code to use in 3rd party apps like Google Authenticator.
 * the server returns qrCode as png image in base64 format
 *
 * @throws exception if the user already have mfa-enabled
 * ``authorized user``
 */
export declare function enrollMfa(): Promise<IEnrollMfaResponse>;
/**
 * pre enroll Multi-Factor Auth Code to use in 3rd party apps like Google Authenticator.
 * the server returns qrCode as png image in base64 format
 *
 * @throws exception if the user already have mfa-enabled
 * ``authorized user``
 */
export declare function preEnrollMFAAuthenticatorApp(): Promise<IPreEnrollMFAAuthenticatorAppResponse>;
/**
 * enroll Multi-Factor Auth Code to use in 3rd party apps like Google Authenticator.
 */
export declare function enrollMFAAuthenticatorApp(body: WithoutMFAToken<IEnrollMFAAuthenticatorApp>): Promise<void>;
/**
 * pre enroll Multi-Factor SMS
 * the server returns otcToken that should be sent to the enroll function with the code that was sent to
 */
export declare function preEnrollMFASMS(body: WithoutMFAToken<IPreEnrollMFASMS>): Promise<IPreEnrollMFASMSResponse>;
/**
 * after pre enroll with SMS, enroll SMS function should be called
 * with the otcToken and the code that has been sent to the phone number that was requested
 */
export declare function enrollMFASMS(body: WithoutMFAToken<IEnrollMFASMS>): Promise<void>;
/**
 * pre enroll Multi-Factor to use with WebAuthn
 * the server returns attestation object
 * the request phone number
 */
export declare function preEnrollMFAWebAuthn(): Promise<IPreEnrollMFAWebAuthnResponse>;
/**
 * after pre enroll with WebAuthn, enroll WebAuthn function should be called
 * with the webauthnToken and the attestation object response
 */
export declare function enrollMFAWebAuthn(body: WithoutMFAToken<IEnrollMFAWebAuthn>): Promise<void>;
/**
 * after enrolling MFA QR code, verify function should be called
 * with the generated code in the Authenticator App
 *
 * @return recoveryCode to use to disable mfa if your device is lost, this code won't show it again.
 * @throws exception if the generated token is invalid
 * ``authorized user``
 */
export declare function verifyMfa(body: IVerifyMfa): Promise<IVerifyMfaResponse>;
/**
 * disable MFA by either passing the recoveryCode or the generated code from the Authenticator App.
 *
 * @throws exception if the generated token or the recoveryCode are incorrect.
 * * ``authorized user``
 */
export declare function disableMfa(body: IDisableMfa): Promise<void>;
/**
 * disable MFA Authenticator App.
 *
 * @throws exception if the generated token is incorrect.
 * * ``authorized user``
 */
export declare function disableMFAAuthenticatorApp(deviceId: string, body: IDisableMfa): Promise<void>;
/**
 * pre disable MFA SMS, should be called if user has just one mfa device
 *
 * @throws exception if pre disable is not required for disable
 * * ``authorized user``
 */
export declare function preDisableMFASMS(deviceId: string): Promise<IPreDisableMFASMSResponse>;
/**
 * after pre disable MFA SMS, disable MFA SMS should be called. can also be called without pre disable if
 * user has more than one mfa device
 *
 * @throws exception if pre disable is not required for disable
 * * ``authorized user``
 */
export declare function disableMFASMS(deviceId: string, body: IDisableMFASMS): Promise<void>;
/**
 * pre disable MFA WebAuthn, should be called if user has just one mfa device
 *
 * @throws exception if pre disable is not required for disable
 * * ``authorized user``
 */
export declare function preDisableMFAWebAuthn(deviceId: string): Promise<IPreDisableMFAWebAuthnResponse>;
/**
 * after pre disable MFA WebAuthn, disable MFA WebAuthn should be called. can also be called without pre disable if
 * user has more than one mfa device
 *
 * @throws exception if pre disable is not required for disable
 * * ``authorized user``
 */
export declare function disableMFAWebAuthn(deviceId: string, body: IDisableMFAWebAuthn): Promise<void>;
/**
 * returns user mfa devices list splitted into 3 arrays. webauthn, phones and authenticators.
 */
export declare function getMFADevices(): Promise<UserMFADevicesResponse>;
/**
 * pre enroll Multi-Factor Auth Code to use in 3rd party apps like Google Authenticator.
 * the server returns qrCode as png image in base64 format
 */
export declare function preEnrollMFAAuthenticatorAppForLogin(body: IPreEnrollMFA): Promise<IPreEnrollMFAAuthenticatorAppResponse>;
/**
 * after pre enroll with authenticator app, enroll authenticator app function should be called
 * with the generated code in the Authenticator App
 */
export declare function enrollMFAAuthenticatorAppForLogin(body: IEnrollMFAAuthenticatorApp): Promise<ILoginResponse>;
/**
 * after pre enroll with authenticator app, enroll authenticator app function should be called
 * with the generated code in the Authenticator App
 */
export declare function enrollMFAAuthenticatorAppForLoginV2(body: IEnrollMFAAuthenticatorApp): Promise<ILoginResponseV3>;
/**
 * after login succeeded with mfaRequired token response, this function should be called
 * with the selected authenticator app id, mfaToken and the generated code from your authenticator app.
 */
export declare function verifyMFAAuthenticatorAppForLogin(deviceId: string, body: IVerifyMFAAuthenticatorApp): Promise<ILoginResponse>;
/**
 * pre verify Multi-Factor Email Code
 * the server returns otcToken that should be sent to the verify function with the code that was sent to
 */
export declare function preVerifyMFAEmailCode(body: IPreVerifyMFA): Promise<IPreVerifyMFAEmailCodeResponse>;
/**
 * after pre verify with Email Code, verify Email Code function should be called
 * with the otcToken and the code that has been sent to the email
 */
export declare function verifyMFAEmailCode(body: IVerifyMFAEmailCode): Promise<ILoginResponse>;
/**
 * after pre verify with Email Code, verify Email Code function should be called
 * with the otcToken and the code that has been sent to the email
 */
export declare function verifyMFAEmailCodeV2(body: IVerifyMFAEmailCode): Promise<ILoginResponseV3>;
/**
 * pre enroll Multi-Factor to use with SMS
 * the server returns otcToken that should be sent to the enroll function with the code that was sent to
 * the request phone number
 */
export declare function preEnrollMFASMSForLogin(body: IPreEnrollMFASMS): Promise<IPreEnrollMFASMSResponse>;
/**
 * after pre enroll with SMS, enroll SMS function should be called
 * with the otcToken and the code that has been sent to the phone number that was requested
 */
export declare function enrollMFASMSForLogin(body: IEnrollMFASMS): Promise<ILoginResponse>;
/**
 * after pre enroll with SMS, enroll SMS function should be called
 * with the otcToken and the code that has been sent to the phone number that was requested
 */
export declare function enrollMFASMSForLoginV2(body: IEnrollMFASMS): Promise<ILoginResponseV3>;
/**
 * after login succeeded with mfaRequired token response, if the user asked to use SMS as MFA
 * this function should be called with the selected device id and mfaToken
 */
export declare function preVerifyMFASMSForLogin(deviceId: string, body: IPreVerifyMFA): Promise<IPreVerifyMFASMSResponse>;
/**
 * after pre verify with SMS, this function should be called with otcToken, mfaToken and the code
 * that has been sent to the selected device.
 */
export declare function verifyMFASMSForLogin(deviceId: string, body: IVerifyMFASMS): Promise<ILoginResponse>;
/**
 * after pre verify with SMS, this function should be called with otcToken, mfaToken and the code
 * that has been sent to the selected device.
 */
export declare function verifyMFASMSForLoginV2(deviceId: string, body: IVerifyMFASMS): Promise<ILoginResponseV3>;
/**
 * pre enroll Multi-Factor to use with WebAuthn
 * the server returns attestation object
 * the request phone number
 */
export declare function preEnrollMFAWebAuthnForLogin(body: IPreEnrollMFA): Promise<IPreEnrollMFAWebAuthnResponse>;
/**
 * after pre enroll with WebAuthn, enroll WebAuthn function should be called
 * with the webauthnToken and the attestation object response
 */
export declare function enrollMFAWebAuthnForLogin(body: IEnrollMFAWebAuthn): Promise<ILoginResponse>;
/**
 * after pre enroll with WebAuthn, enroll WebAuthn function should be called
 * with the webauthnToken and the attestation object response
 */
export declare function enrollMFAWebAuthnForLoginV2(body: IEnrollMFAWebAuthn): Promise<ILoginResponseV3>;
/**
 * after login succeeded with mfaRequired token response, if the user asked to use WebAuthn as MFA
 * this function should be called with the selected device id and mfaToken.
 */
export declare function preVerifyMFAWebAuthnForLogin(deviceId: string, body: IPreVerifyMFA): Promise<IPreVerifyMFAWebAuthnResponse>;
/**
 * after pre verify with WebAuthn, this function should be called with webauthnTokenToken, mfaToken
 * and the assertion response.
 */
export declare function verifyMFAWebAuthnForLogin(deviceId: string, body: IVerifyMFAWebAuthn): Promise<ILoginResponse>;
/**
 * after pre verify with WebAuthn, this function should be called with webauthnTokenToken, mfaToken
 * and the assertion response.
 */
export declare function verifyMFAWebAuthnForLoginV2(deviceId: string, body: IVerifyMFAWebAuthn): Promise<ILoginResponseV3>;
/**
 * SSO Configurations
 */
/**
 *  Retrieve SAML configurations from server by logged in user (tenantId, vendorId)
 *
 *  @return {enabled: false} if no saml configuration found. else ISamlConfiguration
 * * ``authorized user``
 */
export declare function getSamlConfiguration(): Promise<ISamlConfiguration>;
/**
 *  Update SAML configuration by logged in user (tenantId, vendorId)
 * * ``authorized user``
 */
export declare function updateSamlConfiguration(body: IUpdateSamlConfiguration): Promise<ISamlConfiguration>;
/**
 *  Retrieve 'Vendor' Saml config from server by logged in user (tenantId, vendorId)
 *
 *  @throws exception 'ACS url information not found' if no saml vendor configuration found.
 * * ``authorized user``
 */
export declare function getSamlVendorConfiguration(): Promise<ISamlVendorConfigResponse>;
/**
 *  Update Vendor Saml metadata by logged in user (tenantId, vendorId)
 *
 *  @return {enabled: false} if no saml configuration found. else ISamlConfiguration
 * * ``authorized user``
 */
export declare function updateSamlVendorMetadata(body: IUpdateSamlVendorMetadata): Promise<ISamlConfiguration>;
/**
 *  Validate Saml configuration's domain by logged in user (tenantId, vendorId)
 *
 *  @return {enabled: false} if no saml configuration found. else ISamlConfiguration
 * * ``authorized user``
 */
export declare function validateSamlDomain(): Promise<ISamlConfiguration>;
/**
 *  Get Saml roles for authorization
 * @return array of role IDs
 */
export declare function getSamlRoles(): Promise<string[]>;
/**
 *  Get Saml roles groups
 * @return array of groups and assigend role IDs
 */
export declare function getSamlRolesGroups(): Promise<ISamlRolesGroup[]>;
/**
 *  Update Saml roles for authorization
 */
export declare function updateSamlRoles({ roleIds, }: IUpdateSamlRoles): Promise<void>;
/**
 *  Create Saml group roles for authorization
 */
export declare function createSamlGroup({ roleIds, group, }: ICreateSamlGroup): Promise<void>;
/**
 *  Update Saml group roles for authorization
 */
export declare function updateSamlGroup({ roleIds, group, id, }: IUpdateSamlGroup): Promise<void>;
/**
 *  Delete Saml group
 */
export declare function deleteSamlGroup({ id }: {
    id: string;
}): Promise<void>;
/**
 *  Retrieve OIDC configurations from server by logged in user (vendorId)
 *
 *  @return {active: true} if no oidc configuration found. else IOidcConfiguration
 * * ``authorized user``
 */
export declare function getOidcConfiguration(): Promise<IOidcConfiguration>;
/**
 *  Check if one or more saml/oidc configuration are active
 *
 **  @return {isActive: true/false}
 */
export declare function getSSOPublicConfiguration(): Promise<ISSOPublicConfiguration>;
/**
 *  Get social logins providers configurations for vendor
 * @return array of providers configurations
 */
export declare function getSocialLoginProviders(): Promise<ISocialLoginProviderConfiguration[]>;
/**
 *  ##### Public route
 *  Get social logins providers configurations V2 supports dev credentials as well
 * @return array of providers configurations
 */
export declare function getSocialLoginProvidersV2(): Promise<ISocialLoginProviderConfigurationV2[]>;
/**
 *  ##### Authenticated route
 *  Get social logins providers configurations V2 supports dev credentials as well
 * @return array of providers configurations
 */
export declare function getSocialLoginProvidersV2ForAuthenticatedUser(): Promise<ISocialLoginProviderConfigurationV2[]>;
/**
 *  Get social logins custom providers configurations
 * @return array of custom providers configurations
 */
export declare function getCustomSocialLoginProvidersV1(): Promise<ICustomSocialLoginProviderConfigurationV1>;
/**
 * Login using social login
 * @return cookie with refresh token
 */
export declare function loginViaSocialLogin({ provider, code, idToken, redirectUri, codeVerifier, metadata, invitationToken, state, }: ILoginViaSocialLogin): Promise<ILoginViaSocialLoginResponse>;
/**
 * Get vendor secure access configuration
 */
export declare function getVendorConfig(): Promise<IVendorConfig>;
/**
 * Sign up new user
 * create new user with a new tenant
 */
export declare function signUpUser(body: ISignUpUser): Promise<ISignUpResponse>;
/**
 * Get all current user active sessions
 */
export declare function getCurrentUserSessions(): Promise<ISessionResponse[]>;
/**
 * Get current user session
 */
export declare function getCurrentUserSession(): Promise<ISessionResponse>;
/**
 * Revoke sessions for user
 */
export declare function revokeSessionsForUser(userId: string): Promise<void>;
/**
 * Get session configurations
 */
export declare function getSessionConfigurations(): Promise<ISessionConfigurations>;
/**
 * Create or update session configurations
 */
export declare function createOrUpdateSessionConfigrations(body: ISessionConfigurations): Promise<void>;
/**
 * Delete user session
 */
export declare function deleteSessionForUser(id: string): Promise<void>;
/**
 * Delete all user sessions
 */
export declare function deleteAllSessionsForUser(): Promise<void>;
/**
 * Access tokens Configurations
 */
/**
 * Get user access tokens data
 */
export declare function getUserAccessTokensData(): Promise<IGetUserAccessTokens>;
/**
 * Get tenant access tokens data
 */
export declare function getTenantAccessTokensData(): Promise<IGetTenantAccessTokens>;
/**
 * Delete Tenant access Token
 */
export declare function deleteTenantAccessToken({ id, }: IDeleteAccessToken): Promise<void>;
/**
 * Delete Tenant access Token
 */
export declare function deleteUserAccessToken({ id, }: IDeleteAccessToken): Promise<void>;
/**
 * Create User Access Token.
 */
export declare function createUserAccessToken(body: ICreateUserAccessTokenData): Promise<IUserApiTokensData>;
/**
 * Create Tenant Access Token
 */
export declare function createTenantAccessToken(body: ICreateTenantAccessTokenData): Promise<ITenantApiTokensData>;
/**
 * Api tokens Configurations
 */
/**
 * Get user api tokens data
 */
export declare function getUserApiTokensData(): Promise<IUserApiTokensData[]>;
/**
 * Get tenant api tokens data
 */
export declare function getTenantApiTokensData(): Promise<ITenantApiTokensData[]>;
/**
 *  Update User Api Tokens
 */
export declare function updateUserApiTokensData(body: IUpdateUserApiTokensData): Promise<IUserApiTokensData>;
/**
 * Update Tenant Api Tokens
 */
export declare function updateTenantApiTokensData(body: IUpdateTenantApiTokensData): Promise<ITenantApiTokensData>;
/**
 * Delete Tenant Api Token
 */
export declare function deleteTenantApiToken({ tokenId, }: IDeleteApiToken): Promise<void>;
/**
 * Delete Tenant Api Token
 */
export declare function deleteUserApiToken({ tokenId, }: IDeleteApiToken): Promise<void>;
/**
 * Get Tenant Api Token Creator User
 */
export declare function getUserById({ userId, }: IGetUserById): Promise<IUserIdResponse>;
/**
 * Checks if remember MFA device is enabled for user.
 */
export declare function checkIfAllowToRememberMfaDevice(mfaToken: string): Promise<IAllowedToRememberMfaDevice>;
/**
 * Passwordless prelogin authentication
 */
export declare function passwordlessPreLogin({ type, ...body }: IPasswordlessPreLogin): Promise<void>;
export declare function passwordlessPostLoginV2({ type, ...body }: IPasswordlessPostLogin): Promise<ILoginResponseV3>;
export declare function passwordlessPostLogin({ type, ...body }: IPasswordlessPostLogin): Promise<ILoginResponse>;
/**
 * Check if tenant invitation token is valid
 * @param token - invitation token
 * @returns tenant name
 */
export declare function verifyInviteToken({ token, }: IVerifyInviteToken): Promise<string>;
/**
 * SSO Configurations V1
 */
/**
 *  Retrieve SSO configurations from server by logged in user (tenantId, vendorId)
 *
 *  @return ISSOConfiguration[]
 * * ``authorized user``
 */
export declare function getSSOConfigurations(): Promise<ISSOConfiguration[]>;
/**
 *  Create SSO configuration by logged in user (tenantId, vendorId)
 *
 *  @returns ISSOConfiguration
 * * ``authorized user``
 */
export declare function createSSOConfiguration(body: IUpdateSSOConfiguration): Promise<ISSOConfiguration>;
/**
 *  Update SSO configuration by logged in user (tenantId, vendorId)
 *
 *  @returns ISSOConfiguration
 * * ``authorized user``
 */
export declare function updateSSOConfiguration(ssoConfigId: string, body: IUpdateSSOConfiguration): Promise<ISSOConfiguration>;
/**
 *  Delete SSO configuration by logged in user (tenantId, vendorId)
 * * ``authorized user``
 */
export declare function deleteSSOConfiguration(ssoConfigId: string): Promise<void>;
/**
 *  Create SSO configuration by metadata by logged in user (tenantId, vendorId)
 *
 *  @returns ISSOConfiguration
 * * ``authorized user``
 */
export declare function createSSOConfigurationByMetadata(body: IUpdateSamlVendorMetadata): Promise<ISSOConfiguration>;
/**
 *  Update SSO configuration by metadata by logged in user (tenantId, vendorId)
 *
 *  @returns ISSOConfiguration
 * * ``authorized user``
 */
export declare function updateSSOConfigurationByMetadata(ssoConfigId: string, body: IUpdateSamlVendorMetadata): Promise<ISSOConfiguration>;
/**
 *  Create SSO configuration by metadata url by logged in user (tenantId, vendorId)
 *
 *  @returns ISSOConfiguration
 * * ``authorized user``
 */
export declare function createSSOConfigurationByMetadataUrl(body: ICreateOrUpdateSSOConfigurationByMetadataUrl): Promise<ISSOConfiguration>;
/**
 *  Update SSO configuration by metadata url by logged in user (tenantId, vendorId)
 *
 *  @returns ISSOConfiguration
 * * ``authorized user``
 */
export declare function updateSSOConfigurationByMetadataUrl(ssoConfigId: string, body: ICreateOrUpdateSSOConfigurationByMetadataUrl): Promise<ISSOConfiguration>;
/**
 *  Create SSO configuration domain by logged in user (tenantId, vendorId)
 *
 *  @returns ISSODomain
 * * ``authorized user``
 */
export declare function createSSODomain(ssoConfigId: string, body: ICreateSSODomain): Promise<ISSODomain>;
/**
 *  Create SSO configuration domain by logged in user (tenantId, vendorId)
 * * ``authorized user``
 */
export declare function deleteSSODomain(ssoConfigId: string, domainId: string): Promise<void>;
/**
 *  Validate SSO configuration domain by logged in user (tenantId, vendorId)
 * * ``authorized user``
 */
export declare function validateSSODomain(ssoConfigId: string, domainId: string): Promise<void>;
/**
 *  Get SSO configuration default roles by logged in user (tenantId, vendorId)
 * * ``authorized user``
 */
export declare function getSSODefaultRoles(ssoConfigId: string): Promise<ISSOConfigurationDefaultRoles>;
/**
 *  Create SSO configuration default roles by logged in user (tenantId, vendorId)
 * * ``authorized user``
 */
export declare function setSSODefaultRoles(ssoConfigId: string, body: IUpdateSamlRoles): Promise<void>;
/**
 *  Create SSO configuration group roles for authorization
 */
export declare function createSSOGroup(ssoConfigId: string, body: ICreateSamlGroup): Promise<void>;
/**
 *  Update SSO configuration group roles for authorization
 */
export declare function updateSSOGroup(ssoConfigId: string, { roleIds, group, id }: IUpdateSamlGroup): Promise<void>;
/**
 *  Delete SSO configuration group
 */
export declare function deleteSSOGroup(ssoConfigId: string, groupId: string): Promise<void>;
/**
 *  Get SSO configuration groups
 */
export declare function getSSOGroups(ssoConfigId: string): Promise<ISamlRolesGroup[]>;
/**
 * Check if requested email address has sso configuration
 * If true, this function will return the sso address to navigate to
 * else, return null
 */
export declare function preLoginV2(body: IPreLogin): Promise<IPreLoginWithIdpTypeResponse | null>;
/**
 * After calling preLogin and navigated to SSO url, the IDP will redirect you to the redirect url
 * with code and state
 */
export declare function oidcPostLoginV2(body: IOidcPostLoginV2): Promise<ILoginResponse>;
export declare function exchangeOAuthTokensV2(body: IExchangeOAuthTokens): Promise<ILoginResponseV3>;
export declare function silentOAuthRefreshTokenV2(): Promise<ILoginResponseV3>;
export declare function exchangeOAuthTokens(body: IExchangeOAuthTokens): Promise<ILoginResponse>;
export declare function silentOAuthRefreshToken(): Promise<ILoginResponse>;
/**
 * reset phone should be called in case user want to reset his phone number
 * when using sms authentication strategy. a 6-digits code will be send to the user email.
 */
export declare function resetPhoneNumber(body: IResetPhoneNumber): Promise<IResetPhoneNumberResponse>;
/**
 * verify reset phone should be called after reset phone number request
 * with the token received from the reset phone number request and a code that was sent to the user email
 */
export declare function verifyResetPhoneNumber(body: IVerifyResetPhoneNumber): Promise<IVerifyResetPhoneNumberResponse>;
/**
 * change phone number with verification.
 */
export declare function changePhoneNumberWithVerification(body: IChangePhoneNumberWithVerification): Promise<IChangePhoneNumberWithVerificationResponse>;
/**
 * verify new phone number.
 */
export declare function verifyChangePhoneNumber(body: IVerifyChangePhoneNumber): Promise<void>;
/**
 * change phone number should be called after verify reset phone number with the new phone number
 */
export declare function changePhoneNumber(body: IChangePhoneNumber): Promise<void>;
/**
 * webauthn prelogin should be called when the user wants to be authenticated using his device/android/usb key
 */
export declare function webAuthnPreLogin(body: IWebAuthnPreLogin): Promise<IWebAuthnPreLoginResponse>;
/**
 * webauthn postlogin should be called after the user used his authenticator (device/android/usb key) in order to login
 */
export declare function webAuthnPostLogin(body: IWebAuthnPostLogin): Promise<ILoginResponse>;
/**
 * webauthn postlogin should be called after the user used his authenticator (device/android/usb key) in order to login
 */
export declare function webAuthnPostLoginV2(body: IWebAuthnPostLogin): Promise<ILoginResponseV3>;
/**
 * webauthn create new device should be called once the user wants to add new device as authenticator
 */
export declare function webAuthnCreateNewDeviceSession(): Promise<ICreateNewDeviceSessionResponse>;
/**
 * get webauthn devices should be called in order to get user's webAuthn devices
 */
export declare function getWebAuthnDevices(): Promise<IWebAuthnDevices>;
/**
 * delete webauthn device should be called in order to delete user's webAuthn device
 */
export declare function deleteWebAuthnDevice(deviceId: string): Promise<void>;
/**
 * webauthn verify new device should be called after the user used his authenticator in order to register the new device
 */
export declare function verifyNewDeviceSession(body: IVerifyNewWebAuthnDevice): Promise<void>;
/**
 * ##### Public route
 * Get public vendor auth strategies public configuration
 */
export declare function getVendorPublicAuthStrategiesConfig(): Promise<IAuthStrategiesConfig>;
/**
 * ##### Authenticated route
 * Get public vendor auth strategies public configuration
 */
export declare function getPublicAuthStrategiesConfigForAuthenticatedUser(): Promise<IAuthStrategiesConfig>;
/**
 * Get vendor mfa strategies configuration
 */
export declare function getMFAStrategiesConfig(): Promise<IMFAStrategiesResponse>;
/**
 * Get user permissions and roles
 */
export declare function getUserAuthorization(): Promise<IGetUserAuthorizationResponse>;
/**
 * Get user profile
 */
export declare function getMeV2(): Promise<IUserProfile>;
/**
 * @returns me and authorization response with entitlements inside user.entitlements
 * Me request will be executed, and me authorization and entitlements will be executed according to FF and configuration.
 */
export declare function getMeAndEntitlements(): Promise<IUserProfile>;
/**
 * generate step-up session
 * this request returns the step up details to continue step up, or the generated login response when stepped up jwt received from the BE
 */
export declare function generateStepupSession(body: GenerateStepUpRequest): Promise<GenerateStepUpResponse | ILoginResponseV3>;
