"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadAllowSignUps = loadAllowSignUps;
exports.resetSignUpStateSoft = resetSignUpStateSoft;
exports.signUpSaga = signUpSaga;
exports.signUpUser = signUpUser;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _effects = require("redux-saga/effects");
var _restApi = require("@frontegg/rest-api");
var _reducer = require("../reducer");
var _interfaces = require("./interfaces");
var _interfaces2 = require("../interfaces");
var _mfaRequiredState = require("../LoginState/sagas/mfaRequiredState.saga");
var _utils = require("../../utils");
var _utils2 = require("../LoginState/utils");
var _saga = require("../Security/SecurityPolicyState/saga");
const _excluded = ["phoneNumber"],
  _excluded2 = ["events", "url"];
function* loadAllowSignUps() {
  yield (0, _effects.put)(_reducer.actions.setSignUpState({
    loading: true
  }));
  try {
    const policy = yield (0, _effects.call)(_restApi.api.auth.getVendorConfig);
    const policyWithCustomLoginAuthStrategy = yield (0, _saga.getSecurityPolicyPublicStateWithCustomLogin)(policy);
    const {
      allowSignups: allowSignUps,
      allowNotVerifiedUsersLogin
    } = policy;
    yield (0, _effects.put)(_reducer.actions.setSignUpState({
      loading: false,
      allowSignUps,
      allowNotVerifiedUsersLogin,
      firstLoad: false
    }));
    yield (0, _effects.put)(_reducer.actions.setSecurityPolicyPublicState({
      policy: policyWithCustomLoginAuthStrategy,
      loading: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setSignUpState({
      loading: false,
      error: (0, _utils.errorHandler)(e),
      firstLoad: false
    }));
  }
}
const extractPhoneNumber = _ref => {
  let rest = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
  return rest;
};
function* signUpUser(_ref2) {
  let {
      payload: {
        events,
        url
      }
    } = _ref2,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref2.payload, _excluded2);
  yield (0, _effects.put)(_reducer.actions.setSignUpState({
    loading: true
  }));
  try {
    const {
      routes,
      onRedirectTo
    } = yield (0, _effects.select)(state => state.auth);
    const {
      shouldActivate,
      user,
      tenantId,
      userId,
      tenants = [],
      activeTenant
    } = yield (0, _effects.call)(_restApi.api.auth.signUpUser,
    //Currently we are not supporting phone number in signup in the backend
    //Remove this line when we will support it (also make sure when field is optional no empty string is sent)
    extractPhoneNumber(payload));
    if (!payload.invitationToken) {
      var _events$signUpComplet;
      const {
        email,
        name,
        companyName,
        phoneNumber
      } = payload;
      const signUpCompletePayload = {
        email,
        name,
        companyName,
        url,
        phoneNumber: phoneNumber || undefined,
        authenticationType: _interfaces2.AuthenticationTypes.PASSWORD,
        id: userId,
        tenantId,
        createdAt: new Date()
      };
      events == null ? void 0 : (_events$signUpComplet = events.signUpComplete) == null ? void 0 : _events$signUpComplet.call(events, signUpCompletePayload);
      (0, _utils.reportGTMEvent)(_utils.GTMEventAction.SIGNUP_COMPLETED, signUpCompletePayload);
    }
    if (!shouldActivate && user && (0, _utils2.isMfaRequired)(user)) {
      const mfaRequiredState = yield (0, _mfaRequiredState.getMfaRequiredState)(user);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl);
    } else {
      const {
        tenantsState
      } = yield (0, _effects.select)(state => state.auth);
      yield (0, _effects.put)(_reducer.actions.setSignUpState({
        loading: false,
        shouldActivate,
        stage: _interfaces.SignUpStage.SignUpSuccess
      }));
      yield (0, _effects.put)(_reducer.actions.setState({
        user,
        isAuthenticated: !!(user != null && user.accessToken),
        tenantsState: (0, _extends2.default)({}, tenantsState, {
          tenants,
          activeTenant
        })
      }));
    }
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    yield (0, _effects.put)(_reducer.actions.setSignUpState({
      loading: false,
      error: (0, _utils.errorHandler)(e)
    }));
  }
  yield (0, _effects.put)(_reducer.actions.setSignUpState({
    loading: false
  }));
}
function* resetSignUpStateSoft() {
  const {
    allowSignUps,
    allowNotVerifiedUsersLogin
  } = yield (0, _effects.select)(state => state.auth.signUpState);
  yield (0, _effects.put)(_reducer.actions.resetSignUpState());
  yield (0, _effects.put)(_reducer.actions.setSignUpState({
    allowSignUps,
    allowNotVerifiedUsersLogin
  }));
}
function* signUpSaga() {
  yield (0, _effects.takeLeading)(_reducer.actions.signUpUser, signUpUser);
  yield (0, _effects.takeLeading)(_reducer.actions.resetSignUpStateSoft, resetSignUpStateSoft);
}