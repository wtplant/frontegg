"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ssoSagas = ssoSagas;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _effects = require("redux-saga/effects");
var _restApi = require("@frontegg/rest-api");
var _reducer = require("../reducer");
var _interfaces = require("./interfaces");
var _helpers = require("../../helpers");
var _utils = require("../../utils");
const _excluded = ["callback"],
  _excluded2 = ["callback", "ssoConfigId"],
  _excluded3 = ["callback", "ssoConfigId"],
  _excluded4 = ["callback", "ssoConfigId"];
function* loadOidc() {
  try {
    const oidcConfiguration = yield (0, _effects.call)(_restApi.api.auth.getOidcConfiguration);
    return oidcConfiguration;
  } catch (e) {
    return null;
  }
}
function* loadSaml() {
  try {
    const samlMetadata = yield (0, _effects.call)(_restApi.api.metadata.getSamlMetadata);
    return samlMetadata;
  } catch (e) {
    return null;
  }
}
function* loadSSOConfigurationsV2() {
  try {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.LOAD_SSO_CONFIGURATIONS,
      value: true
    }));
    const [oidcConfiguration, samlMetadata] = yield (0, _effects.all)([(0, _effects.call)(loadOidc), (0, _effects.call)(loadSaml)]);
    const ssoConfigurations = yield (0, _effects.call)(_restApi.api.auth.getSSOConfigurations);
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations,
      oidcConfiguration,
      samlMetadata
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.LOAD_SSO_CONFIGURATIONS,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.LOAD_SSO_CONFIGURATIONS,
      value: false
    }));
  }
}
function* saveSSOConfigurationV2({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION,
    value: true
  }));
  const {
      callback
    } = payload,
    ssoConfiguration = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded);
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    var _ssoConfiguration$ena;
    const newSsoConfiguration = yield (0, _effects.call)(_restApi.api.auth.createSSOConfiguration, (0, _extends2.default)({}, ssoConfiguration, {
      enabled: (_ssoConfiguration$ena = ssoConfiguration.enabled) != null ? _ssoConfiguration$ena : false
    }));
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: [...ssoConfigurations, newSsoConfiguration]
    }));
    callback == null ? void 0 : callback(newSsoConfiguration);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION,
      value: false
    }));
  }
}
function* saveSSOConfigurationByMetadata({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA,
    value: true
  }));
  const {
    configFile,
    callback
  } = payload;
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    const metadata = yield (0, _helpers.readFileAsText)(configFile);
    const newSsoConfiguration = yield (0, _effects.call)(_restApi.api.auth.createSSOConfigurationByMetadata, {
      metadata
    });
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: [...ssoConfigurations, newSsoConfiguration]
    }));
    callback == null ? void 0 : callback(newSsoConfiguration);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA,
      value: false
    }));
  }
}
function* updateSSOConfiguration({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.UPDATE_SSO_CONFIGURATION,
    value: true
  }));
  const {
      callback,
      ssoConfigId
    } = payload,
    ssoConfiguration = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded2);
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    const newSsoConfiguration = yield (0, _effects.call)(_restApi.api.auth.updateSSOConfiguration, ssoConfigId, ssoConfiguration);
    const newSsoConfigurations = ssoConfigurations.map(ssoConfig => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(newSsoConfiguration);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.UPDATE_SSO_CONFIGURATION,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.UPDATE_SSO_CONFIGURATION,
      value: false
    }));
  }
}
function* updateSSOConfigurationByMetadata({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.UPDATE_SSO_CONFIGURATION_BY_METADATA,
    value: true
  }));
  const {
    callback,
    ssoConfigId,
    configFile
  } = payload;
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    const metadata = yield (0, _helpers.readFileAsText)(configFile);
    const newSsoConfiguration = yield (0, _effects.call)(_restApi.api.auth.updateSSOConfigurationByMetadata, ssoConfigId, {
      metadata
    });
    const newSsoConfigurations = ssoConfigurations.map(ssoConfig => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(newSsoConfiguration);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.UPDATE_SSO_CONFIGURATION,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.UPDATE_SSO_CONFIGURATION,
      value: false
    }));
  }
}
function* deleteSSOConfiguration({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.DELETE_SSO_CONFIGURATION,
    value: true
  }));
  const {
    ssoConfigId,
    callback
  } = payload;
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    yield (0, _effects.call)(_restApi.api.auth.deleteSSOConfiguration, ssoConfigId);
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: ssoConfigurations.filter(({
        id
      }) => id !== ssoConfigId)
    }));
    callback == null ? void 0 : callback(true);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.DELETE_SSO_CONFIGURATION,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.DELETE_SSO_CONFIGURATION,
      value: false
    }));
  }
}
function* saveSSODomain({
  payload
}) {
  const {
      callback,
      ssoConfigId
    } = payload,
    body = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded3);
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.SAVE_SSO_DOMAIN,
    value: true
  }));
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    const domain = yield (0, _effects.call)(_restApi.api.auth.createSSODomain, ssoConfigId, body);
    const newSsoConfigurations = ssoConfigurations.map(ssoConfig => {
      if (ssoConfig.id === ssoConfigId) {
        return (0, _extends2.default)({}, ssoConfig, {
          domains: [...ssoConfig.domains, domain]
        });
      }
      return ssoConfig;
    });
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(domain);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.SAVE_SSO_DOMAIN,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.SAVE_SSO_DOMAIN,
      value: false
    }));
  }
}
function* deleteSSODomain({
  payload
}) {
  const {
    ssoConfigId,
    domainId,
    callback
  } = payload;
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.DELETE_SSO_DOMAIN,
    value: true
  }));
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    yield (0, _effects.call)(_restApi.api.auth.deleteSSODomain, ssoConfigId, domainId);
    const newSsoConfigurations = ssoConfigurations.map(ssoConfig => {
      if (ssoConfig.id === ssoConfigId) {
        return (0, _extends2.default)({}, ssoConfig, {
          domains: ssoConfig.domains.filter(({
            id
          }) => id !== domainId)
        });
      }
      return ssoConfig;
    });
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(true);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.DELETE_SSO_DOMAIN,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.DELETE_SSO_DOMAIN,
      value: false
    }));
  }
}
function* validateSSODomainV2({
  payload
}) {
  const {
    callback,
    domainId,
    ssoConfigId
  } = payload;
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.VALIDATE_SSO_DOMAIN,
    value: true
  }));
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    yield (0, _effects.call)(_restApi.api.auth.validateSSODomain, ssoConfigId, domainId);
    const newSsoConfigurations = ssoConfigurations.map(ssoConfig => {
      if (ssoConfig.id === ssoConfigId) {
        return (0, _extends2.default)({}, ssoConfig, {
          domains: ssoConfig.domains.map(ssoDomain => ssoDomain.id === domainId ? (0, _extends2.default)({}, ssoDomain, {
            validated: true
          }) : ssoDomain)
        });
      }
      return ssoConfig;
    });
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(true);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.VALIDATE_SSO_DOMAIN,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.VALIDATE_SSO_DOMAIN,
      value: false
    }));
  }
}
function* setSSODefaultRoles({
  payload: {
    callback,
    ssoConfigId,
    roleIds
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.UPDATE_SSO_DEFAULT_ROLES,
    value: true
  }));
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    yield (0, _effects.call)(_restApi.api.auth.setSSODefaultRoles, ssoConfigId, {
      roleIds
    });
    const newSsoConfigurations = ssoConfigurations.map(ssoConfig => {
      if (ssoConfig.id === ssoConfigId) {
        return (0, _extends2.default)({}, ssoConfig, {
          roleIds
        });
      }
      return ssoConfig;
    });
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(true);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.UPDATE_SSO_DEFAULT_ROLES,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.UPDATE_SSO_DEFAULT_ROLES,
      value: false
    }));
  }
}
function* setSSOGroups({
  payload: {
    groupsToAdd,
    groupsToDelete,
    ssoConfigId,
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.SAVE_SSO_GROUPS,
    value: true
  }));
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    yield (0, _effects.all)(groupsToDelete.map(groupId => (0, _effects.call)(_restApi.api.auth.deleteSSOGroup, ssoConfigId, groupId)));
    yield (0, _effects.all)(groupsToAdd.map(group => (0, _effects.call)(_restApi.api.auth.createSSOGroup, ssoConfigId, group)));
    const groups = yield (0, _effects.call)(_restApi.api.auth.getSSOGroups, ssoConfigId);
    const newSsoConfigurations = ssoConfigurations.map(ssoConfig => {
      if (ssoConfig.id === ssoConfigId) {
        return (0, _extends2.default)({}, ssoConfig, {
          groups
        });
      }
      return ssoConfig;
    });
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(true);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.SAVE_SSO_GROUPS,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.SAVE_SSO_GROUPS,
      value: false
    }));
  }
}
function* updateSSOGroups({
  payload: {
    ssoConfigId,
    changedGroups,
    callback
  }
}) {
  try {
    yield (0, _effects.all)(changedGroups.map(group => (0, _effects.call)(_restApi.api.auth.updateSSOGroup, ssoConfigId, group)));
    callback == null ? void 0 : callback(true);
  } catch (error) {
    yield (0, _effects.put)(_reducer.actions.setSSOError({
      key: _interfaces.SSOStateKeys.SAVE_SSO_GROUPS,
      value: (0, _utils.errorHandler)(error)
    }));
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.SAVE_SSO_GROUPS,
      value: false
    }));
  }
}
function* saveSSOConfigurationByUrl({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA,
    value: true
  }));
  const {
    metadataUrl,
    configMetadata,
    ssoConfigId,
    callback
  } = payload;
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    const body = {
      url: metadataUrl,
      configMetadata
    };
    let newSsoConfiguration;
    let newSsoConfigurations;
    if (ssoConfigId) {
      newSsoConfiguration = yield (0, _effects.call)(_restApi.api.auth.updateSSOConfigurationByMetadataUrl, ssoConfigId, body);
      newSsoConfigurations = ssoConfigurations.map(ssoConfig => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
    } else {
      newSsoConfiguration = yield (0, _effects.call)(_restApi.api.auth.createSSOConfigurationByMetadataUrl, body);
      newSsoConfigurations = [newSsoConfiguration, ...ssoConfigurations];
    }
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(newSsoConfiguration);
  } catch (error) {
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA,
      value: false
    }));
  }
}
function* saveSSOConfigurationByData({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setSSOLoader({
    key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION,
    value: true
  }));
  const {
      callback,
      ssoConfigId
    } = payload,
    body = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded4);
  const ssoConfigurations = yield (0, _effects.select)(state => state.auth.ssoState.ssoConfigurations);
  try {
    let newSsoConfiguration;
    let newSsoConfigurations;
    if (ssoConfigId) {
      newSsoConfiguration = yield (0, _effects.call)(_restApi.api.auth.updateSSOConfiguration, ssoConfigId, body);
      newSsoConfigurations = ssoConfigurations.map(ssoConfig => ssoConfig.id === ssoConfigId ? newSsoConfiguration : ssoConfig);
    } else {
      newSsoConfiguration = yield (0, _effects.call)(_restApi.api.auth.createSSOConfiguration, body);
      newSsoConfigurations = [newSsoConfiguration, ...ssoConfigurations];
    }
    yield (0, _effects.put)(_reducer.actions.setSSOState({
      ssoConfigurations: newSsoConfigurations
    }));
    callback == null ? void 0 : callback(newSsoConfiguration);
  } catch (error) {
    callback == null ? void 0 : callback(null, error);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSSOLoader({
      key: _interfaces.SSOStateKeys.SAVE_SSO_CONFIGURATION_BY_METADATA,
      value: false
    }));
  }
}
function* ssoSagas() {
  yield (0, _effects.takeEvery)(_reducer.actions.loadSSOConfigurationsV2, loadSSOConfigurationsV2);
  yield (0, _effects.takeEvery)(_reducer.actions.saveSSOConfigurationV2, saveSSOConfigurationV2);
  yield (0, _effects.takeEvery)(_reducer.actions.saveSSODomain, saveSSODomain);
  yield (0, _effects.takeEvery)(_reducer.actions.deleteSSODomain, deleteSSODomain);
  yield (0, _effects.takeEvery)(_reducer.actions.validateSSODomainV2, validateSSODomainV2);
  yield (0, _effects.takeEvery)(_reducer.actions.updateSSOConfiguration, updateSSOConfiguration);
  yield (0, _effects.takeEvery)(_reducer.actions.deleteSSOConfiguration, deleteSSOConfiguration);
  yield (0, _effects.takeEvery)(_reducer.actions.setSSOGroups, setSSOGroups);
  yield (0, _effects.takeEvery)(_reducer.actions.updateSSOGroups, updateSSOGroups);
  yield (0, _effects.takeEvery)(_reducer.actions.setSSODefaultRoles, setSSODefaultRoles);
  yield (0, _effects.takeEvery)(_reducer.actions.saveSSOConfigurationByMetadata, saveSSOConfigurationByMetadata);
  yield (0, _effects.takeEvery)(_reducer.actions.updateSSOConfigurationByMetadata, updateSSOConfigurationByMetadata);
  yield (0, _effects.takeEvery)(_reducer.actions.saveSSOConfigurationByUrl, saveSSOConfigurationByUrl);
  yield (0, _effects.takeEvery)(_reducer.actions.saveSSOConfigurationByData, saveSSOConfigurationByData);
}