"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUsersWithRoles = getUsersWithRoles;
exports.loadBreachedPasswordUsers = loadBreachedPasswordUsers;
exports.loadBreachedPasswordUsersMock = loadBreachedPasswordUsersMock;
exports.loadInactiveUsers = loadInactiveUsers;
exports.loadInactiveUsersMock = loadInactiveUsersMock;
exports.loadInsights = loadInsights;
exports.loadInsightsMock = loadInsightsMock;
exports.loadRecommendations = loadRecommendations;
exports.loadRecommendationsMock = loadRecommendationsMock;
exports.loadUnenrolledMfaUsers = loadUnenrolledMfaUsers;
exports.loadUnenrolledMfaUsersMock = loadUnenrolledMfaUsersMock;
exports.loadUsersTableSecurityCenter = loadUsersTableSecurityCenter;
exports.securityCenterSagaWrapper = securityCenterSagaWrapper;
exports.securityCenterSagas = securityCenterSagas;
exports.securityCenterSagasMock = securityCenterSagasMock;
exports.sendBulkResetBreachedPasswordEmails = sendBulkResetBreachedPasswordEmails;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _effects = require("redux-saga/effects");
var _reducer = require("../../reducer");
var _utils = require("../../../utils");
var _restApi = require("@frontegg/rest-api");
var _types = require("./types");
var _helpers = require("../../../helpers");
var _dummy = require("../../dummy");
const _excluded = ["callback"];
/**
 * This function is used to wrap sagas of the security page.
 * This function returns function,
 * that execute the saga it gets as a parameter,
 * and after it execute loadRecommendations and loadInsights sagas.
 * We need to call loadRecommendations and loadInsights after all change in the security page,
 * in order to keep the recommendations and insights updated.
 * @param action - saga to execute
 */
function securityCenterSagaWrapper(action) {
  return function* (props) {
    const [securityCenterFeatureFlag] = yield (0, _effects.call)(_helpers.getFeatureFlags, ['security-center-admin-portal-major-version']);
    yield action(props);
    if (securityCenterFeatureFlag) {
      yield loadRecommendations();
      yield loadInsights();
    }
  };
}
function* loadRecommendations() {
  const key = _types.SecurityCenterStateKeys.RECOMMENDATIONS;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  try {
    var _scoring$score;
    const {
      recommendations,
      scoring
    } = yield (0, _effects.call)(_restApi.api.securityCenter.getRecommendations);
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
      recommendations: recommendations.items,
      score: (_scoring$score = scoring == null ? void 0 : scoring.score) != null ? _scoring$score : 0
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
      key,
      value: false
    }));
  }
}
function* loadInsights() {
  const key = _types.SecurityCenterStateKeys.INSIGHTS;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  try {
    const {
      insights
    } = yield (0, _effects.call)(_restApi.api.securityCenter.getInsights);
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
      insights: insights.items
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
      key,
      value: false
    }));
  }
}
function* sendResetBreachedPasswordEmail(_ref) {
  let {
      payload: {
        callback
      }
    } = _ref,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref.payload, _excluded);
  const key = _types.SecurityCenterStateKeys.SEND_BREACHED_PASSWORD_EMAIL;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateError({
    key,
    value: false
  }));
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  try {
    yield (0, _effects.call)(_restApi.api.auth.forgotPassword, payload);
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false, e);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
      key,
      value: false
    }));
  }
}
function* sendBulkResetBreachedPasswordEmails({
  payload: {
    callback
  }
}) {
  const key = _types.SecurityCenterStateKeys.SEND_BULK_RESET_BREACHED_PASSWORD_EMAILS;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateError({
    key,
    value: false
  }));
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  try {
    yield (0, _effects.call)(_restApi.api.users.sendResetBreachedPasswordEmails);
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
      key,
      value: false
    }));
  }
}

/**
 * This function gets users as we got from getUsersV3,
 * and returns the combined object of those users with their roles.
 * @param users - array of users
 */
function* getUsersWithRoles(users) {
  const usersIds = users.map(user => user.id);
  const allRoles = yield (0, _effects.call)(_restApi.api.roles.getRoles);
  const usersRoles = yield (0, _effects.call)(_restApi.api.users.getUsersRoles, {
    ids: usersIds
  });
  const usersWithRoles = users.map(user => {
    var _usersRoles$find, _ref2;
    const userRolesIds = usersRoles == null ? void 0 : (_usersRoles$find = usersRoles.find(role => role.userId === user.id)) == null ? void 0 : _usersRoles$find.roleIds;
    return (0, _extends2.default)({}, user, {
      roles: (_ref2 = userRolesIds == null ? void 0 : userRolesIds.map(roleId => {
        var _allRoles$find;
        return (_allRoles$find = allRoles == null ? void 0 : allRoles.find(role => role.id === roleId)) != null ? _allRoles$find : [];
      })) != null ? _ref2 : []
    });
  });
  return usersWithRoles;
}

/**
 * This function is doing the logic needed in order to display a table in a generic way.
 * It calls getUsersV3 based on the params, combined the response of users with roles,
 * and load it to the correct state by the updateStateKey.
 * @param key - key for loaders / errors
 * @param tableState - the state of the specific table
 * @param updateStateKey - the key of the specific table to be updated in the state
 * @param _offset - page offset
 * @param _limit - limit per page
 * @param _preset - preset to be send according to the table type
 * @param _email - email input as searched
 *
 */
function* loadUsersTableSecurityCenter({
  key,
  tableState,
  updateStateKey,
  _offset: offset,
  _limit: limit,
  _preset,
  _email,
  _maxInactiveSeconds
}) {
  var _ref3, _tableState$queryPara, _ref4, _tableState$queryPara2;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateError({
    key,
    value: false
  }));
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  const _offset = (_ref3 = offset != null ? offset : tableState == null ? void 0 : (_tableState$queryPara = tableState.queryParams) == null ? void 0 : _tableState$queryPara._offset) != null ? _ref3 : 0;
  const _limit = (_ref4 = limit != null ? limit : tableState == null ? void 0 : (_tableState$queryPara2 = tableState.queryParams) == null ? void 0 : _tableState$queryPara2._limit) != null ? _ref4 : 10;
  const tableStateQueryParams = (0, _extends2.default)({
    _offset,
    _limit,
    _includeSubTenants: false,
    _preset,
    _maxInactiveSeconds
  }, !!_email && {
    _email
  });
  try {
    const {
      items: usersItems,
      _metadata: {
        totalItems,
        totalPages
      }
    } = yield (0, _effects.call)(_restApi.api.users.getUsersV3, tableStateQueryParams);
    const partialTableObj = {
      totalUsersItems: totalItems,
      totalUsersPages: totalPages,
      usersPageOffset: _offset,
      queryParams: (0, _extends2.default)({
        _offset,
        _limit,
        _maxInactiveSeconds
      }, !!_email && {
        _email
      })
    };
    if (usersItems.length) {
      const usersWithRoles = yield getUsersWithRoles(usersItems);
      yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
        [updateStateKey]: (0, _extends2.default)({
          users: usersWithRoles
        }, partialTableObj)
      }));
    } else {
      yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
        [updateStateKey]: (0, _extends2.default)({
          users: []
        }, partialTableObj)
      }));
    }
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
      key,
      value: false
    }));
  }
}
function* loadBreachedPasswordUsers({
  payload
}) {
  var _select;
  const key = _types.SecurityCenterStateKeys.BREACHED_PASSWORD_USERS_TABLE;
  const breachedPasswordUsersTable = yield (_select = (0, _effects.select)(state => {
    var _state$auth$securityC;
    return (_state$auth$securityC = state.auth.securityCenterState) == null ? void 0 : _state$auth$securityC.breachedPasswordUsersTable;
  })) != null ? _select : {};
  yield loadUsersTableSecurityCenter((0, _extends2.default)({
    key,
    updateStateKey: 'breachedPasswordUsersTable',
    _preset: _restApi.GetUsersFilterPreset.BREACHED_PASSWORDS,
    tableState: breachedPasswordUsersTable
  }, payload));
}
function* loadUnenrolledMfaUsers({
  payload
}) {
  var _select2;
  const key = _types.SecurityCenterStateKeys.UNENROLLED_MFA_USERS_TABLE;
  const unenrolledMfaUsersTable = yield (_select2 = (0, _effects.select)(state => {
    var _state$auth$securityC2;
    return (_state$auth$securityC2 = state.auth.securityCenterState) == null ? void 0 : _state$auth$securityC2.unenrolledMfaUsersTable;
  })) != null ? _select2 : {};
  yield loadUsersTableSecurityCenter((0, _extends2.default)({
    key,
    updateStateKey: 'unenrolledMfaUsersTable',
    _preset: _restApi.GetUsersFilterPreset.MFA_UNENROLLED,
    tableState: unenrolledMfaUsersTable
  }, payload));
}
function* loadInactiveUsers({
  payload
}) {
  var _select3;
  const key = _types.SecurityCenterStateKeys.INACTIVE_USERS_TABLE;
  const inactiveUsersTable = yield (_select3 = (0, _effects.select)(state => {
    var _state$auth$securityC3;
    return (_state$auth$securityC3 = state.auth.securityCenterState) == null ? void 0 : _state$auth$securityC3.inactiveUsersTable;
  })) != null ? _select3 : {};
  yield loadUsersTableSecurityCenter((0, _extends2.default)({
    key,
    updateStateKey: 'inactiveUsersTable',
    _preset: _restApi.GetUsersFilterPreset.INACTIVE,
    tableState: inactiveUsersTable
  }, payload));
}
function* securityCenterSagas() {
  yield (0, _effects.takeEvery)(_reducer.actions.loadRecommendations, loadRecommendations);
  yield (0, _effects.takeEvery)(_reducer.actions.loadInsights, loadInsights);
  yield (0, _effects.takeEvery)(_reducer.actions.sendResetBreachedPasswordEmail, sendResetBreachedPasswordEmail);
  yield (0, _effects.takeEvery)(_reducer.actions.sendBulkResetBreachedPasswordEmails, sendBulkResetBreachedPasswordEmails);
  yield (0, _effects.takeEvery)(_reducer.actions.loadBreachedPasswordUsers, loadBreachedPasswordUsers);
  yield (0, _effects.takeEvery)(_reducer.actions.loadUnenrolledMfaUsers, loadUnenrolledMfaUsers);
  yield (0, _effects.takeEvery)(_reducer.actions.loadInactiveUsers, loadInactiveUsers);
}

//MOCK SAGAS

function* loadRecommendationsMock() {
  const key = _types.SecurityCenterStateKeys.RECOMMENDATIONS;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  yield (0, _effects.delay)(500);
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
    recommendations: _dummy.securityCenterRecommendationsMock.recommendations.items,
    score: _dummy.securityCenterRecommendationsMock.scoring.score
  }));
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: false
  }));
}
function* loadInsightsMock() {
  const key = _types.SecurityCenterStateKeys.INSIGHTS;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  yield (0, _effects.delay)(500);
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
    insights: _dummy.securityCenterInsightsMock.insights.items
  }));
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: false
  }));
}
function* loadBreachedPasswordUsersMock() {
  const key = _types.SecurityCenterStateKeys.BREACHED_PASSWORD_USERS_TABLE;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  yield (0, _effects.delay)(500);
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
    breachedPasswordUsersTable: _dummy.securityCenterBreachedPasswordUsersMock
  }));
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: false
  }));
}
function* loadUnenrolledMfaUsersMock() {
  const key = _types.SecurityCenterStateKeys.UNENROLLED_MFA_USERS_TABLE;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  yield (0, _effects.delay)(500);
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
    unenrolledMfaUsersTable: _dummy.securityCenterUnenrolledMfaUsersMock
  }));
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: false
  }));
}
function* loadInactiveUsersMock() {
  const key = _types.SecurityCenterStateKeys.INACTIVE_USERS_TABLE;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  yield (0, _effects.delay)(500);
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterState({
    inactiveUsersTable: _dummy.securityCenterInactivityPasswordUsersMock
  }));
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: false
  }));
}
function* sendResetBreachedPasswordEmailMock({
  payload: {
    callback
  }
}) {
  const key = _types.SecurityCenterStateKeys.SEND_BREACHED_PASSWORD_EMAIL;
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: true
  }));
  yield (0, _effects.delay)(500);
  callback == null ? void 0 : callback(true);
  yield (0, _effects.put)(_reducer.actions.setSecurityCenterStateLoader({
    key,
    value: false
  }));
}
function* securityCenterSagasMock() {
  yield (0, _effects.takeEvery)(_reducer.actions.loadRecommendations, loadRecommendationsMock);
  yield (0, _effects.takeEvery)(_reducer.actions.loadInsights, loadInsightsMock);
  yield (0, _effects.takeEvery)(_reducer.actions.loadBreachedPasswordUsers, loadBreachedPasswordUsersMock);
  yield (0, _effects.takeEvery)(_reducer.actions.loadUnenrolledMfaUsers, loadUnenrolledMfaUsersMock);
  yield (0, _effects.takeEvery)(_reducer.actions.loadInactiveUsers, loadInactiveUsersMock);
  yield (0, _effects.takeEvery)(_reducer.actions.sendResetBreachedPasswordEmail, sendResetBreachedPasswordEmailMock);
}