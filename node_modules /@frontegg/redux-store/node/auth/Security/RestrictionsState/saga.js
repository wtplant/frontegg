"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.restrictionsSagaMock = restrictionsSagaMock;
exports.restrictionsSagas = restrictionsSagas;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _effects = require("redux-saga/effects");
var _restApi = require("@frontegg/rest-api");
var _reducer = require("../../reducer");
var _uuid = require("uuid");
var _constants = require("../../../constants");
var _dummy = require("../../dummy");
var _utils = require("../../utils");
var _utils2 = require("../../../utils");
var _saga = require("../SecurityCenterState/saga");
const _excluded = ["callback"],
  _excluded2 = ["callback"],
  _excluded3 = ["callback"],
  _excluded4 = ["callback"],
  _excluded5 = ["callback"],
  _excluded6 = ["callback"],
  _excluded7 = ["callback"],
  _excluded8 = ["callback"];
const selectIpRestrictionsState = () => (0, _effects.select)(_ => _[_constants.authStoreName].restrictionsState.ipRestrictions);
const selectUserIp = () => (0, _effects.select)(_ => _[_constants.authStoreName].userIp);
const selectEmailDomainRestrictionsState = () => (0, _effects.select)(_ => _[_constants.authStoreName].restrictionsState.emailDomainRestrictions);
function* loadEmailDomainRestrictions() {
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    loading: true,
    error: null
  }));
  try {
    const restrictionsConfig = yield (0, _effects.call)(_restApi.api.auth.getDomainRestrictionsConfig);
    const restrictions = yield (0, _effects.call)(_restApi.api.auth.getDomainRestrictions);
    const filteredRestrictions = restrictions.items.filter(restriction => restriction.type === restrictionsConfig.listType);
    yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
      data: {
        restrictions: filteredRestrictions,
        config: restrictionsConfig
      },
      loading: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
      error: (0, _utils2.errorHandler)(e),
      loading: false
    }));
  }
}
function* saveEmailDomainRestriction(_ref) {
  let {
      payload: {
        callback
      }
    } = _ref,
    newRestriction = (0, _objectWithoutPropertiesLoose2.default)(_ref.payload, _excluded);
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    saving: true,
    error: null
  }));
  const emailDomainRestrictionsState = yield selectEmailDomainRestrictionsState();
  try {
    var _emailDomainRestricti2;
    yield (0, _effects.call)(_restApi.api.auth.createDomainRestriction, newRestriction);
    const restrictions = yield (0, _effects.call)(_restApi.api.auth.getDomainRestrictions);
    const filteredRestrictions = restrictions.items.filter(restriction => {
      var _emailDomainRestricti;
      return restriction.type === ((_emailDomainRestricti = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti.config.listType);
    });
    yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
      data: {
        config: ((_emailDomainRestricti2 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti2.config) || {
          active: false,
          blockPublicDomains: false,
          listType: newRestriction.type
        },
        restrictions: filteredRestrictions
      },
      saving: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
      saving: false,
      error: (0, _utils2.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null, e);
  }
}
function* saveEmailDomainRestrictionConfig(_ref2) {
  let {
      payload: {
        callback
      }
    } = _ref2,
    config = (0, _objectWithoutPropertiesLoose2.default)(_ref2.payload, _excluded2);
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    saving: true,
    error: null
  }));
  try {
    const updatedConfig = yield (0, _effects.call)(_restApi.api.auth.updateDomainRestrictionConfig, config);
    const restrictions = yield (0, _effects.call)(_restApi.api.auth.getDomainRestrictions);
    const filteredRestrictions = restrictions.items.filter(restriction => restriction.type === updatedConfig.listType);
    yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
      data: {
        config: updatedConfig,
        restrictions: filteredRestrictions
      },
      saving: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
      saving: false,
      error: (0, _utils2.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null, e);
  }
}
function* deleteEmailDomainRestriction({
  payload: {
    id
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    saving: true,
    error: null
  }));
  const emailDomainRestrictionsState = yield selectEmailDomainRestrictionsState();
  try {
    var _emailDomainRestricti4;
    yield (0, _effects.call)(_restApi.api.auth.deleteDomainRestriction, id);
    const restrictions = yield (0, _effects.call)(_restApi.api.auth.getDomainRestrictions);
    const filteredRestrictions = restrictions.items.filter(restriction => {
      var _emailDomainRestricti3;
      return restriction.type === ((_emailDomainRestricti3 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti3.config.listType);
    });
    yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
      data: {
        config: ((_emailDomainRestricti4 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti4.config) || {
          active: false,
          blockPublicDomains: false,
          listType: _restApi.RestrictionType.ALLOW
        },
        restrictions: filteredRestrictions
      },
      saving: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
      saving: false,
      error: (0, _utils2.errorHandler)(e)
    }));
  }
}
const getPagination = statePagination => {
  var _statePagination$_fil, _statePagination$_lim, _statePagination$_off;
  return {
    _filter: (_statePagination$_fil = statePagination == null ? void 0 : statePagination._filter) != null ? _statePagination$_fil : _restApi.RestrictionType.ALLOW,
    _limit: (_statePagination$_lim = statePagination == null ? void 0 : statePagination._limit) != null ? _statePagination$_lim : 10,
    _offset: (_statePagination$_off = statePagination == null ? void 0 : statePagination._offset) != null ? _statePagination$_off : 0
  };
};
function* loadIpRestrictions() {
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    loading: true,
    error: null
  }));
  try {
    const ipRestrictionState = yield selectIpRestrictionsState();
    const restrictionsConfig = yield (0, _effects.call)(_restApi.api.auth.getIPRestrictionsConfig);
    const pagination = getPagination({
      _filter: restrictionsConfig.strategy,
      _limit: ipRestrictionState.pagination._limit,
      _offset: ipRestrictionState.pagination._offset
    });
    const {
      items: restrictions,
      _metadata: {
        totalPages
      }
    } = yield (0, _effects.call)(_restApi.api.auth.getIPRestrictions, pagination);
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      data: {
        restrictions: restrictions,
        config: restrictionsConfig
      },
      totalPages,
      pagination,
      loading: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      error: (0, _utils2.errorHandler)(e),
      loading: false
    }));
  }
}
function* checkIfUserIpValid() {
  try {
    const {
      valid: userIpValid
    } = yield (0, _effects.call)(_restApi.api.auth.testCurrentIpInAllowList);
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      userIpValid
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      error: (0, _utils2.errorHandler)(e)
    }));
  }
}
function* addCurrentUserIpAndActivate({
  payload: {
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: true,
    error: null
  }));
  try {
    const userIp = yield selectUserIp();
    yield (0, _effects.all)([(0, _effects.call)(_restApi.api.auth.createIPRestriction, {
      ip: userIp,
      isActive: true,
      description: 'My IP',
      strategy: _restApi.RestrictionType.ALLOW
    }), (0, _effects.call)(_restApi.api.auth.updateIPRestrictionConfig, {
      isActive: true
    })]);
    const ipRestrictionState = yield selectIpRestrictionsState();
    const pagination = getPagination(ipRestrictionState.pagination);
    const {
      items: restrictions,
      _metadata: {
        totalPages
      }
    } = yield (0, _effects.call)(_restApi.api.auth.getIPRestrictions, pagination);
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      data: {
        config: {
          isActive: true,
          strategy: _restApi.RestrictionType.ALLOW
        },
        restrictions
      },
      userIpValid: true,
      pagination,
      totalPages,
      saving: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      saving: false,
      error: e
    }));
    callback == null ? void 0 : callback(false, e);
  }
}
function* saveIpRestriction(_ref3) {
  let {
      payload: {
        callback
      }
    } = _ref3,
    newRestriction = (0, _objectWithoutPropertiesLoose2.default)(_ref3.payload, _excluded3);
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: true,
    error: null
  }));
  const ipRestrictionsState = yield selectIpRestrictionsState();
  try {
    var _ipRestrictionsState$, _ipRestrictionsState$2;
    yield (0, _effects.call)(_restApi.api.auth.createIPRestriction, newRestriction);
    const ipRestrictionState = yield selectIpRestrictionsState();
    const pagination = getPagination(ipRestrictionState.pagination);
    const {
      items: restrictions,
      _metadata: {
        totalPages
      }
    } = yield (0, _effects.call)(_restApi.api.auth.getIPRestrictions, pagination);
    yield checkIfUserIpValid();
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      data: {
        config: (_ipRestrictionsState$ = (_ipRestrictionsState$2 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$2.config) != null ? _ipRestrictionsState$ : {
          isActive: false,
          strategy: _restApi.RestrictionType.ALLOW
        },
        restrictions
      },
      pagination,
      totalPages,
      saving: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      saving: false,
      error: (0, _utils2.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null, e);
  }
}
function* saveIpRestrictionsConfig(_ref4) {
  let {
      payload: {
        callback
      }
    } = _ref4,
    config = (0, _objectWithoutPropertiesLoose2.default)(_ref4.payload, _excluded4);
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: true,
    error: null
  }));
  try {
    yield (0, _effects.call)(_restApi.api.auth.updateIPRestrictionConfig, config);
    const ipRestrictionState = yield selectIpRestrictionsState();
    const restrictionsConfig = yield (0, _effects.call)(_restApi.api.auth.getIPRestrictionsConfig);
    const pagination = getPagination((0, _extends2.default)({}, ipRestrictionState.pagination, {
      _filter: restrictionsConfig.strategy
    }));
    const {
      items: restrictions,
      _metadata: {
        totalPages
      }
    } = yield (0, _effects.call)(_restApi.api.auth.getIPRestrictions, pagination);
    yield checkIfUserIpValid();
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      data: {
        config: restrictionsConfig,
        restrictions
      },
      pagination,
      totalPages,
      saving: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      saving: false,
      error: (0, _utils2.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null, e);
  }
}
function* deleteIpRestriction({
  payload: {
    id,
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: true,
    error: null
  }));
  const ipRestrictionsState = yield selectIpRestrictionsState();
  try {
    var _ipRestrictionsState$3;
    yield (0, _effects.call)(_restApi.api.auth.deleteIPRestriction, id);
    const ipRestrictionState = yield selectIpRestrictionsState();
    const pagination = getPagination(ipRestrictionState.pagination);
    const {
      items: restrictions,
      _metadata: {
        totalPages
      }
    } = yield (0, _effects.call)(_restApi.api.auth.getIPRestrictions, pagination);
    yield checkIfUserIpValid();
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      data: {
        config: ((_ipRestrictionsState$3 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$3.config) || {
          isActive: false,
          strategy: _restApi.RestrictionType.ALLOW
        },
        restrictions
      },
      pagination,
      totalPages,
      saving: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      saving: false,
      error: (0, _utils2.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null, e);
  }
}
function* restrictionsSagas() {
  yield (0, _effects.takeLeading)(_reducer.actions.loadIpRestrictions, (0, _saga.securityCenterSagaWrapper)(loadIpRestrictions));
  yield (0, _effects.takeLeading)(_reducer.actions.loadEmailDomainRestrictions, (0, _saga.securityCenterSagaWrapper)(loadEmailDomainRestrictions));
  yield (0, _effects.takeEvery)(_reducer.actions.saveIpRestriction, (0, _saga.securityCenterSagaWrapper)(saveIpRestriction));
  yield (0, _effects.takeEvery)(_reducer.actions.saveIpRestrictionsConfig, (0, _saga.securityCenterSagaWrapper)(saveIpRestrictionsConfig));
  yield (0, _effects.takeEvery)(_reducer.actions.deleteIpRestriction, (0, _saga.securityCenterSagaWrapper)(deleteIpRestriction));
  yield (0, _effects.takeEvery)(_reducer.actions.checkIfUserIpValid, (0, _saga.securityCenterSagaWrapper)(checkIfUserIpValid));
  yield (0, _effects.takeEvery)(_reducer.actions.addCurrentUserIpAndActivate, (0, _saga.securityCenterSagaWrapper)(addCurrentUserIpAndActivate));
  yield (0, _effects.takeEvery)(_reducer.actions.saveEmailDomainRestriction, (0, _saga.securityCenterSagaWrapper)(saveEmailDomainRestriction));
  yield (0, _effects.takeEvery)(_reducer.actions.saveEmailDomainRestrictionsConfig, (0, _saga.securityCenterSagaWrapper)(saveEmailDomainRestrictionConfig));
  yield (0, _effects.takeEvery)(_reducer.actions.deleteEmailDomainRestriction, (0, _saga.securityCenterSagaWrapper)(deleteEmailDomainRestriction));
}

/*********************************
 *  Preview Sagas
 *********************************/

function* loadIpRestrictionsMock() {
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    loading: true,
    error: null
  }));
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    data: {
      restrictions: _dummy.dummyIps.filter(ip => ip.strategy === _dummy.dummyIpConfig.strategy),
      config: _dummy.dummyIpConfig
    },
    totalPages: 1,
    pagination: {
      _filter: _restApi.RestrictionType.ALLOW,
      _limit: 50,
      _offset: 0
    },
    loading: false
  }));
}
function* checkIfUserIpValidMock() {
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    loading: true,
    error: null
  }));
  try {
    const ipRestrictionState = yield selectIpRestrictionsState();
    const userIp = _dummy.dummyIps[0].ip;
    const userIpValid = !!ipRestrictionState.data.restrictions.find(restriction => restriction.isActive && restriction.ip === userIp);
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      userIpValid,
      loading: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      error: (0, _utils2.errorHandler)(e),
      loading: false
    }));
  }
}
function* saveIpRestrictionMock(_ref5) {
  var _ipRestrictionsState$4, _ipRestrictionsState$5, _newRestriction$isAct;
  let {
      payload: {
        callback
      }
    } = _ref5,
    newRestriction = (0, _objectWithoutPropertiesLoose2.default)(_ref5.payload, _excluded5);
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: true,
    error: null
  }));
  const ipRestrictionsState = yield selectIpRestrictionsState();
  const filteredRestrictions = ipRestrictionsState.data.restrictions.filter(r => r.ip !== newRestriction.ip);
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    data: {
      config: (_ipRestrictionsState$4 = (_ipRestrictionsState$5 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$5.config) != null ? _ipRestrictionsState$4 : {
        isActive: false,
        strategy: _restApi.RestrictionType.ALLOW
      },
      restrictions: [...filteredRestrictions, (0, _extends2.default)({}, newRestriction, {
        createdAt: new Date(),
        updatedAt: new Date(),
        id: (0, _uuid.v4)(),
        isActive: (_newRestriction$isAct = newRestriction.isActive) != null ? _newRestriction$isAct : true,
        strategy: ipRestrictionsState.data.config.strategy
      })]
    },
    totalPages: 1,
    pagination: {
      _filter: _restApi.RestrictionType.ALLOW,
      _limit: 50,
      _offset: 0
    },
    saving: false
  }));
  callback == null ? void 0 : callback(true);
}
function* saveIpRestrictionsConfigMock(_ref6) {
  var _ipRestrictionsState$6, _ipRestrictionsState$7, _ipRestrictionsState$8;
  let {
      payload: {
        callback
      }
    } = _ref6,
    config = (0, _objectWithoutPropertiesLoose2.default)(_ref6.payload, _excluded6);
  const ipRestrictionsState = yield selectIpRestrictionsState();
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: true,
    error: null
  }));
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    data: {
      config: (0, _extends2.default)({}, (_ipRestrictionsState$6 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$6.config, config),
      restrictions: (_ipRestrictionsState$7 = (_ipRestrictionsState$8 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$8.restrictions) != null ? _ipRestrictionsState$7 : []
    },
    pagination: {
      _filter: _restApi.RestrictionType.ALLOW,
      _limit: 50,
      _offset: 0
    },
    totalPages: 1,
    saving: false
  }));
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: false,
    error: null
  }));
  callback == null ? void 0 : callback(true);
}
function* deleteIpRestrictionMock({
  payload: {
    id,
    callback
  }
}) {
  var _ipRestrictionsState$9;
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: true,
    error: null
  }));
  const ipRestrictionsState = yield selectIpRestrictionsState();
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    data: {
      config: ((_ipRestrictionsState$9 = ipRestrictionsState.data) == null ? void 0 : _ipRestrictionsState$9.config) || {
        isActive: false,
        strategy: _restApi.RestrictionType.ALLOW
      },
      restrictions: ipRestrictionsState.data.restrictions.filter(ip => ip.id !== id)
    },
    pagination: {
      _filter: _restApi.RestrictionType.ALLOW,
      _limit: 50,
      _offset: 0
    },
    totalPages: 1,
    saving: false,
    error: null
  }));
  callback == null ? void 0 : callback(true);
}
function* addCurrentUserIpAndActivateMock({
  payload: {
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
    saving: true,
    error: null
  }));
  try {
    const userIp = yield selectUserIp();
    yield (0, _effects.put)(_reducer.actions.saveIpRestriction({
      ip: userIp,
      description: 'My IP',
      isActive: true
    }));
    yield (0, _effects.put)(_reducer.actions.saveIpRestrictionsConfig({
      isActive: true
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setIpRestrictionsState({
      saving: false,
      error: e
    }));
    callback == null ? void 0 : callback(false, e);
  }
}
function* loadEmailDomainRestrictionsMock() {
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    loading: true,
    error: null
  }));
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    loading: false,
    data: {
      restrictions: [{
        domain: 'mock.com',
        id: '1',
        type: _restApi.RestrictionType.ALLOW
      }],
      config: {
        active: true,
        listType: _restApi.RestrictionType.ALLOW,
        blockPublicDomains: false
      }
    }
  }));
}
function* saveEmailDomainRestrictionMock(_ref7) {
  var _emailDomainRestricti5, _emailDomainRestricti6;
  let {
      payload: {
        callback
      }
    } = _ref7,
    restriction = (0, _objectWithoutPropertiesLoose2.default)(_ref7.payload, _excluded7);
  const emailDomainRestrictionsState = yield selectEmailDomainRestrictionsState();
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    saving: true,
    error: null
  }));
  yield (0, _utils.delay)();
  callback == null ? void 0 : callback(true);
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    data: {
      config: ((_emailDomainRestricti5 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti5.config) || {
        active: false,
        blockPublicDomains: false,
        listType: restriction.type
      },
      restrictions: [...(((_emailDomainRestricti6 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti6.restrictions) || []), (0, _extends2.default)({}, restriction, {
        id: Date.now().toString()
      })]
    },
    saving: false
  }));
}
function* saveEmailDomainRestrictionConfigMock(_ref8) {
  var _emailDomainRestricti7;
  let {
      payload: {
        callback
      }
    } = _ref8,
    config = (0, _objectWithoutPropertiesLoose2.default)(_ref8.payload, _excluded8);
  const emailDomainRestrictionsState = yield selectEmailDomainRestrictionsState();
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    saving: true,
    error: null
  }));
  yield (0, _utils.delay)();
  callback == null ? void 0 : callback(true);
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    data: {
      config: {
        active: config.active,
        blockPublicDomains: config.blockPublicDomains || false,
        listType: config.type || _restApi.RestrictionType.ALLOW
      },
      restrictions: [...(((_emailDomainRestricti7 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti7.restrictions) || [])]
    },
    saving: false
  }));
}
function* deleteEmailDomainRestrictionMock({
  payload: {
    id
  }
}) {
  var _emailDomainRestricti8, _emailDomainRestricti9;
  const emailDomainRestrictionsState = yield selectEmailDomainRestrictionsState();
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    saving: true,
    error: null
  }));
  yield (0, _utils.delay)();
  yield (0, _effects.put)(_reducer.actions.setEmailDomainRestrictionsState({
    data: {
      config: ((_emailDomainRestricti8 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti8.config) || {
        active: false,
        blockPublicDomains: false,
        listType: _restApi.RestrictionType.ALLOW
      },
      restrictions: (((_emailDomainRestricti9 = emailDomainRestrictionsState.data) == null ? void 0 : _emailDomainRestricti9.restrictions) || []).filter(restriction => restriction.id === id)
    },
    saving: false
  }));
}
function* restrictionsSagaMock() {
  yield (0, _effects.takeLeading)(_reducer.actions.loadIpRestrictions, loadIpRestrictionsMock);
  yield (0, _effects.takeLeading)(_reducer.actions.loadEmailDomainRestrictions, loadEmailDomainRestrictionsMock);
  yield (0, _effects.takeEvery)(_reducer.actions.saveIpRestriction, saveIpRestrictionMock);
  yield (0, _effects.takeEvery)(_reducer.actions.saveIpRestrictionsConfig, saveIpRestrictionsConfigMock);
  yield (0, _effects.takeEvery)(_reducer.actions.deleteIpRestriction, deleteIpRestrictionMock);
  yield (0, _effects.takeEvery)(_reducer.actions.checkIfUserIpValid, checkIfUserIpValidMock);
  yield (0, _effects.takeEvery)(_reducer.actions.saveEmailDomainRestriction, saveEmailDomainRestrictionMock);
  yield (0, _effects.takeEvery)(_reducer.actions.saveEmailDomainRestrictionsConfig, saveEmailDomainRestrictionConfigMock);
  yield (0, _effects.takeEvery)(_reducer.actions.deleteEmailDomainRestriction, deleteEmailDomainRestrictionMock);
}

// export function* restrictionsSagas() {
//   yield takeLeading(actions.loadEmailDomainRestrictions, loadEmailDomainRestrictions);
//   yield takeEvery(actions.saveEmailDomainRestriction, saveEmailDomainRestriction);
//   yield takeEvery(actions.saveEmailDomainRestrictionsConfig, saveEmailDomainRestrictionConfig);
//   yield takeEvery(actions.deleteEmailDomainRestriction, deleteEmailDomainRestriction);
// }

// /*********************************
//  *  Preview Sagas
//  *********************************/