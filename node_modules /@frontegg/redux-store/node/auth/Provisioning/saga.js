"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.provisionSagas = provisionSagas;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _effects = require("redux-saga/effects");
var _restApi = require("@frontegg/rest-api");
var _reducer = require("../reducer");
var _utils = require("../../utils");
const _excluded = ["callback"],
  _excluded2 = ["id"];
function* loadCountForConnection(connection) {
  const {
    count
  } = yield (0, _effects.call)(_restApi.api.directory.countConfigurationUsers, connection.id);
  return (0, _extends2.default)({}, connection, {
    count
  });
}
function* loadScim2Connections() {
  yield (0, _effects.put)(_reducer.actions.setProvisioningState({
    loading: true,
    error: null
  }));
  try {
    const connections = yield (0, _effects.call)(_restApi.api.directory.getConfigs);
    const connectionsWithCount = yield (0, _effects.all)(connections.map(connection => loadCountForConnection(connection)));
    yield (0, _effects.put)(_reducer.actions.setProvisioningState({
      connections: connectionsWithCount,
      loading: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setProvisioningState({
      error: (0, _utils.errorHandler)(e),
      loading: false
    }));
  }
}
function* createScim2Connection(_ref) {
  let {
      payload: {
        callback
      }
    } = _ref,
    newConnectionBody = (0, _objectWithoutPropertiesLoose2.default)(_ref.payload, _excluded);
  yield (0, _effects.put)(_reducer.actions.setProvisioningState({
    loading: true,
    error: null
  }));
  try {
    const newConnectionResponse = yield (0, _effects.call)(_restApi.api.directory.createConfiguration, newConnectionBody);
    const connections = yield (0, _effects.call)(_restApi.api.directory.getConfigs);
    const connectionsWithCount = yield (0, _effects.all)(connections.map(connection => loadCountForConnection(connection)));
    yield (0, _effects.put)(_reducer.actions.setProvisioningState({
      connections: connectionsWithCount,
      loading: false
    }));
    callback == null ? void 0 : callback(newConnectionResponse);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setProvisioningState({
      error: (0, _utils.errorHandler)(e),
      loading: false
    }));
  }
}
function* updateScim2Connection(_ref2) {
  let {
      payload: {
        id
      }
    } = _ref2,
    updateRequest = (0, _objectWithoutPropertiesLoose2.default)(_ref2.payload, _excluded2);
  yield (0, _effects.put)(_reducer.actions.setProvisioningState({
    loading: true,
    error: null
  }));
  try {
    yield (0, _effects.call)(_restApi.api.directory.updateConfiguration, id, updateRequest);
    const connections = yield (0, _effects.call)(_restApi.api.directory.getConfigs);
    const connectionsWithCount = yield (0, _effects.all)(connections.map(connection => loadCountForConnection(connection)));
    yield (0, _effects.put)(_reducer.actions.setProvisioningState({
      connections: connectionsWithCount,
      loading: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setProvisioningState({
      error: (0, _utils.errorHandler)(e),
      loading: false
    }));
  }
}
function* deleteScim2Connection({
  payload: {
    id,
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setProvisioningState({
    loading: true,
    error: null
  }));
  try {
    yield (0, _effects.call)(_restApi.api.directory.deleteConfiguration, id);
    const connections = yield (0, _effects.call)(_restApi.api.directory.getConfigs);
    const connectionsWithCount = yield (0, _effects.all)(connections.map(connection => loadCountForConnection(connection)));
    yield (0, _effects.put)(_reducer.actions.setProvisioningState({
      connections: connectionsWithCount,
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setProvisioningState({
      error: (0, _utils.errorHandler)(e),
      loading: false
    }));
    callback == null ? void 0 : callback(false, e);
  }
}
function* provisionSagas() {
  yield (0, _effects.takeLeading)(_reducer.actions.loadProvisionConnections, loadScim2Connections);
  yield (0, _effects.takeEvery)(_reducer.actions.createProvisionConnection, createScim2Connection);
  yield (0, _effects.takeEvery)(_reducer.actions.deleteProvisionConnection, deleteScim2Connection);
  yield (0, _effects.takeEvery)(_reducer.actions.updateProvisionConnection, updateScim2Connection);
}