"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.apiTokensSaga = apiTokensSaga;
exports.apiTokensSagaMock = apiTokensSagaMock;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _effects = require("redux-saga/effects");
var _restApi = require("@frontegg/rest-api");
var _reducer = require("../reducer");
var _interfaces = require("./interfaces");
var _dummy = require("../dummy");
var _uuid = require("uuid");
var _utils = require("../../utils");
function* addUserApiToken({
  payload
}) {
  const {
    description,
    expires,
    callback
  } = payload;
  const {
    apiTokensDataUser
  } = yield (0, _effects.select)(state => state.auth.apiTokensState);
  const {
    policy
  } = yield (0, _effects.select)(state => state.auth.securityPolicyState.publicPolicy);
  const isAccessToken = (policy == null ? void 0 : policy.machineToMachineAuthStrategy) === _restApi.MachineToMachineAuthStrategy.AccessToken;
  try {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
      value: true
    }));
    let data;
    let expiresInMinutes = null;
    if (expires) {
      expiresInMinutes = expires * 1440;
    }
    if (isAccessToken) {
      data = yield (0, _effects.call)(_restApi.api.auth.createUserAccessToken, {
        description,
        expiresInMinutes
      });
    } else {
      data = yield (0, _effects.call)(_restApi.api.auth.updateUserApiTokensData, {
        description,
        expiresInMinutes
      });
    }
    yield (0, _effects.put)(_reducer.actions.setApiTokensState({
      showAddTokenDialog: false
    }));
    yield (0, _effects.delay)(200);
    yield (0, _effects.put)(_reducer.actions.setApiTokensState({
      apiTokensDataUser: [(0, _extends2.default)({}, data, {
        type: isAccessToken ? _restApi.MachineToMachineAuthStrategy.AccessToken : _restApi.MachineToMachineAuthStrategy.ClientCredentials
      }), ...apiTokensDataUser],
      successDialog: {
        open: true,
        secret: data.secret,
        clientId: !isAccessToken ? data.clientId : undefined
      }
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
      value: false
    }));
    callback == null ? void 0 : callback(null);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensError({
      key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
      value: (0, _utils.errorHandler)(e)
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
      value: false
    }));
    callback == null ? void 0 : callback(null, e);
  }
}
function* addTenantApiToken({
  payload
}) {
  const {
    description,
    roleIds,
    expires,
    callback
  } = payload;
  const {
    apiTokensDataTenant
  } = yield (0, _effects.select)(state => state.auth.apiTokensState);
  const {
    policy
  } = yield (0, _effects.select)(state => state.auth.securityPolicyState.publicPolicy);
  const isAccessToken = (policy == null ? void 0 : policy.machineToMachineAuthStrategy) === _restApi.MachineToMachineAuthStrategy.AccessToken;
  try {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
      value: true
    }));
    let data;
    let expiresInMinutes = null;
    if (expires) {
      expiresInMinutes = expires * 1440;
    }
    if (isAccessToken) {
      data = yield (0, _effects.call)(_restApi.api.auth.createTenantAccessToken, {
        description,
        expiresInMinutes,
        roleIds
      });
    } else {
      data = yield (0, _effects.call)(_restApi.api.auth.updateTenantApiTokensData, {
        description,
        roleIds,
        expiresInMinutes
      });
    }
    yield (0, _effects.put)(_reducer.actions.setApiTokensState({
      showAddTokenDialog: false
    }));
    yield (0, _effects.delay)(200);
    yield (0, _effects.put)(_reducer.actions.setApiTokensState({
      apiTokensDataTenant: [(0, _extends2.default)({}, data, {
        type: isAccessToken ? _restApi.MachineToMachineAuthStrategy.AccessToken : _restApi.MachineToMachineAuthStrategy.ClientCredentials
      }), ...apiTokensDataTenant],
      successDialog: {
        open: true,
        secret: data.secret,
        clientId: !isAccessToken ? data.clientId : undefined
      }
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
      value: false
    }));
    callback == null ? void 0 : callback(null);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensError({
      key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
      value: (0, _utils.errorHandler)(e)
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
      value: false
    }));
    callback == null ? void 0 : callback(null, e);
  }
}
function* deleteUserApiToken({
  payload
}) {
  const {
    apiTokensDataUser
  } = yield (0, _effects.select)(state => state.auth.apiTokensState);
  const isAccessToken = apiTokensDataUser.some(token => token.id === payload);
  try {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
      value: true
    }));
    if (isAccessToken) {
      yield (0, _effects.call)(_restApi.api.auth.deleteUserAccessToken, {
        id: payload
      });
      yield (0, _effects.put)(_reducer.actions.setApiTokensState({
        apiTokensDataUser: apiTokensDataUser.filter(token => token.id !== payload),
        deleteTokenDialog: {
          open: false,
          id: payload
        }
      }));
    } else {
      yield (0, _effects.call)(_restApi.api.auth.deleteUserApiToken, {
        tokenId: payload
      });
      yield (0, _effects.put)(_reducer.actions.setApiTokensState({
        apiTokensDataUser: apiTokensDataUser.filter(token => token.clientId !== payload),
        deleteTokenDialog: {
          open: false,
          clientId: payload
        }
      }));
    }
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
      value: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensError({
      key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
      value: (0, _utils.errorHandler)(e)
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
      value: false
    }));
  }
}
function* deleteTenantApiToken({
  payload
}) {
  const {
    apiTokensDataTenant
  } = yield (0, _effects.select)(state => state.auth.apiTokensState);
  const isAccessToken = apiTokensDataTenant.some(token => token.id === payload);
  let filteredApiTokensDataTenant = apiTokensDataTenant;
  try {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
      value: true
    }));
    if (isAccessToken) {
      yield (0, _effects.call)(_restApi.api.auth.deleteTenantAccessToken, {
        id: payload
      });
      filteredApiTokensDataTenant = apiTokensDataTenant.filter(token => token.id !== payload);
    } else {
      yield (0, _effects.call)(_restApi.api.auth.deleteTenantApiToken, {
        tokenId: payload
      });
      filteredApiTokensDataTenant = apiTokensDataTenant.filter(token => token.clientId !== payload);
    }
    yield (0, _effects.put)(_reducer.actions.setApiTokensState({
      apiTokensDataTenant: filteredApiTokensDataTenant,
      deleteTokenDialog: {
        open: false,
        id: payload
      }
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
      value: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensError({
      key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
      value: (0, _utils.errorHandler)(e)
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
      value: false
    }));
  }
}
function* loadApiTokens({
  payload
}) {
  if (!(payload != null && payload.silentLoading)) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: true
    }));
  }
  try {
    var _payload$callback;
    const [apiTokensDataUser = [], apiTokensDataTenant = []] = yield (0, _effects.all)([(0, _effects.call)(_restApi.api.auth.getUserApiTokensData), (0, _effects.call)(_restApi.api.auth.getTenantApiTokensData)]);
    yield (0, _effects.put)(_reducer.actions.setApiTokensState({
      apiTokensDataUser,
      apiTokensDataTenant
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: false
    }));
    payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
  } catch (e) {
    var _payload$callback2;
    yield (0, _effects.put)(_reducer.actions.setApiTokensError({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: (0, _utils.errorHandler)(e)
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: false
    }));
    payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
  }
}
function* loadUserApiTokens({
  payload
}) {
  if (!(payload != null && payload.silentLoading)) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: true
    }));
  }
  try {
    var _call, _call2, _accessTokensData$acc, _payload$callback3;
    const apiTokensData = yield (_call = (0, _effects.call)(_restApi.api.auth.getUserApiTokensData)) != null ? _call : [];
    const accessTokensData = yield (_call2 = (0, _effects.call)(_restApi.api.auth.getUserAccessTokensData)) != null ? _call2 : [];
    const accessTokens = (_accessTokensData$acc = accessTokensData.accessTokens) != null ? _accessTokensData$acc : [];
    const allTokens = accessTokens.map(item => (0, _extends2.default)({}, item, {
      type: _restApi.MachineToMachineAuthStrategy.AccessToken
    })).concat(apiTokensData.map(item => (0, _extends2.default)({}, item, {
      type: _restApi.MachineToMachineAuthStrategy.ClientCredentials
    })));
    const sortedTokensByDate = allTokens.sort((date1, date2) => new Date(date2.createdAt) - new Date(date1.createdAt));
    yield (0, _effects.put)(_reducer.actions.setApiTokensState({
      apiTokensDataUser: sortedTokensByDate != null ? sortedTokensByDate : []
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: false
    }));
    payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
  } catch (e) {
    var _payload$callback4;
    yield (0, _effects.put)(_reducer.actions.setApiTokensError({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: (0, _utils.errorHandler)(e)
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: false
    }));
    payload == null ? void 0 : (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, null, e);
  }
}
function* loadTenantApiTokens({
  payload
}) {
  if (!(payload != null && payload.silentLoading)) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: true
    }));
  }
  try {
    var _call3, _call4, _accessTokensData$acc2, _payload$callback5;
    const apiTokensData = yield (_call3 = (0, _effects.call)(_restApi.api.auth.getTenantApiTokensData)) != null ? _call3 : [];
    const accessTokensData = yield (_call4 = (0, _effects.call)(_restApi.api.auth.getTenantAccessTokensData)) != null ? _call4 : [];
    const accessTokens = (_accessTokensData$acc2 = accessTokensData == null ? void 0 : accessTokensData.accessTokens) != null ? _accessTokensData$acc2 : [];
    const allTokens = accessTokens.map(item => (0, _extends2.default)({}, item, {
      type: _restApi.MachineToMachineAuthStrategy.AccessToken
    })).concat(apiTokensData.map(item => (0, _extends2.default)({}, item, {
      type: _restApi.MachineToMachineAuthStrategy.ClientCredentials
    })));
    const sortedTokensByDate = allTokens.sort((date1, date2) => new Date(date2.createdAt) - new Date(date1.createdAt));
    yield (0, _effects.put)(_reducer.actions.setApiTokensState({
      apiTokensDataTenant: sortedTokensByDate != null ? sortedTokensByDate : []
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: false
    }));
    payload == null ? void 0 : (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, true);
  } catch (e) {
    var _payload$callback6;
    yield (0, _effects.put)(_reducer.actions.setApiTokensError({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: (0, _utils.errorHandler)(e)
    }));
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: false
    }));
    payload == null ? void 0 : (_payload$callback6 = payload.callback) == null ? void 0 : _payload$callback6.call(payload, null, e);
  }
}
function* apiTokensSaga() {
  yield (0, _effects.takeLeading)(_reducer.actions.loadApiTokens, loadApiTokens);
  yield (0, _effects.takeLeading)(_reducer.actions.loadUserApiTokens, loadUserApiTokens);
  yield (0, _effects.takeLeading)(_reducer.actions.loadTenantApiTokens, loadTenantApiTokens);
  yield (0, _effects.takeEvery)(_reducer.actions.addUserApiToken, addUserApiToken);
  yield (0, _effects.takeEvery)(_reducer.actions.addTenantApiToken, addTenantApiToken);
  yield (0, _effects.takeLatest)(_reducer.actions.deleteTenantApiToken, deleteTenantApiToken);
  yield (0, _effects.takeLatest)(_reducer.actions.deleteUserApiToken, deleteUserApiToken);
}

/*********************************
 *  Preview Sagas
 *********************************/

function* addTenantApiTokenMock({
  payload
}) {
  const {
    description,
    roleIds,
    callback
  } = payload;
  yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
    key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
    value: true
  }));
  const {
    apiTokensDataTenant
  } = yield (0, _effects.select)(state => state.auth.apiTokensState);
  const newToken = (0, _extends2.default)({}, _dummy.apiTokensDataTenantDemo, {
    description,
    roleIds,
    clientId: `CLIENT_ID_${(0, _uuid.v4)()}`
  });
  yield (0, _effects.put)(_reducer.actions.setApiTokensState({
    showAddTokenDialog: false
  }));
  yield (0, _effects.delay)(200);
  yield (0, _effects.put)(_reducer.actions.setApiTokensState({
    apiTokensDataTenant: [...apiTokensDataTenant, newToken],
    successDialog: {
      open: true,
      secret: newToken.secret,
      clientId: newToken.clientId
    }
  }));
  yield (0, _effects.delay)(200);
  yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
    key: _interfaces.ApiStateKeys.ADD_API_TOKEN,
    value: false
  }));
  callback == null ? void 0 : callback(null);
}
function* deleteTenantApiTokenMock({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
    key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
    value: true
  }));
  yield (0, _effects.delay)(200);
  const apiTokensDataTenant = [_dummy.apiTokensDataTenantDemo];
  yield (0, _effects.put)(_reducer.actions.setApiTokensState({
    apiTokensDataTenant: apiTokensDataTenant.filter(i => i.clientId !== payload),
    deleteTokenDialog: {
      open: false,
      clientId: payload
    }
  }));
  yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
    key: _interfaces.ApiStateKeys.DELETE_API_TOKEN,
    value: false
  }));
}
function* loadApiTokensMock({
  payload
}) {
  var _payload$callback7;
  if (!(payload != null && payload.silentLoading)) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: true
    }));
  }
  const apiTokensDataUser = [_dummy.apiTokensDataDemo];
  const apiTokensDataTenant = [_dummy.apiTokensDataTenantDemo];
  yield (0, _effects.put)(_reducer.actions.setApiTokensState({
    apiTokensDataUser,
    apiTokensDataTenant
  }));
  yield (0, _effects.delay)(200);
  yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
    key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
    value: false
  }));
  payload == null ? void 0 : (_payload$callback7 = payload.callback) == null ? void 0 : _payload$callback7.call(payload, true);
}
function* loadUserApiTokensMock({
  payload
}) {
  var _payload$callback8;
  if (!(payload != null && payload.silentLoading)) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: true
    }));
  }
  const apiTokensDataUser = [_dummy.apiTokensDataDemo];
  yield (0, _effects.put)(_reducer.actions.setApiTokensState({
    apiTokensDataUser
  }));
  yield (0, _effects.delay)(200);
  yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
    key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
    value: false
  }));
  payload == null ? void 0 : (_payload$callback8 = payload.callback) == null ? void 0 : _payload$callback8.call(payload, true);
}
function* loadTenantApiTokensMock({
  payload
}) {
  var _payload$callback9;
  if (!(payload != null && payload.silentLoading)) {
    yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
      key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
      value: true
    }));
  }
  const apiTokensDataTenant = [_dummy.apiTokensDataTenantDemo];
  yield (0, _effects.put)(_reducer.actions.setApiTokensState({
    apiTokensDataTenant
  }));
  yield (0, _effects.delay)(200);
  yield (0, _effects.put)(_reducer.actions.setApiTokensLoader({
    key: _interfaces.ApiStateKeys.LOAD_API_TOKENS,
    value: false
  }));
  payload == null ? void 0 : (_payload$callback9 = payload.callback) == null ? void 0 : _payload$callback9.call(payload, true);
}
function* apiTokensSagaMock() {
  yield (0, _effects.takeLeading)(_reducer.actions.loadApiTokens, loadApiTokensMock);
  yield (0, _effects.takeLeading)(_reducer.actions.loadUserApiTokens, loadUserApiTokensMock);
  yield (0, _effects.takeLeading)(_reducer.actions.loadTenantApiTokens, loadTenantApiTokensMock);
  yield (0, _effects.takeEvery)(_reducer.actions.addTenantApiToken, addTenantApiTokenMock);
  yield (0, _effects.takeLatest)(_reducer.actions.deleteTenantApiToken, deleteTenantApiTokenMock);
}