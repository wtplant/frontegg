"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.allAccountsSagas = allAccountsSagas;
exports.selectTenantsState = exports.selectAllAccountsState = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _reducer = require("../../reducer");
var _constants = require("../../../constants");
var _stateTypes = require("./types/stateTypes");
var _effects = require("redux-saga/effects");
var _restApi = require("@frontegg/rest-api");
var _utils = require("../../../utils");
var _updateNodeName = require("./utils/updateNodeName");
var _removeNodeFromTree = require("./utils/removeNodeFromTree");
var _appendChildrenToNode = require("./utils/appendChildrenToNode");
var _getAccountsWithUsersCount = require("./utils/getAccountsWithUsersCount");
const selectTenantsState = () => (0, _effects.select)(_ => _[_constants.authStoreName].tenantsState);
exports.selectTenantsState = selectTenantsState;
const selectAllAccountsState = () => (0, _effects.select)(_ => _[_constants.authStoreName].allAccountsState);
exports.selectAllAccountsState = selectAllAccountsState;
function* loadAccounts({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.GET_ACCOUNTS;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    accountsQueryParams
  } = yield selectAllAccountsState();
  const {
    jwt,
    _limit,
    _offset
  } = payload;
  const searchSubTenantsQueryParams = {
    _offset: _offset != null ? _offset : accountsQueryParams._offset,
    _limit: _limit != null ? _limit : accountsQueryParams._limit,
    _subTenantId: payload == null ? void 0 : payload._subTenantId
  };
  try {
    const isSelectedAccountChange = !!jwt;
    if (isSelectedAccountChange) {
      var _payload$_subTenantId;
      const {
        selectedAccount
      } = yield selectAllAccountsState();
      const {
        items,
        _links
      } = yield (0, _effects.call)(_restApi.api.tenants.searchSubTenants, searchSubTenantsQueryParams, {
        jwt
      });
      const tenantsUsersCountArray = yield (0, _effects.call)(_restApi.api.tenants.getTenantsUsersCount, {
        tenantIds: items.map(tenant => tenant.tenantId)
      }, {
        jwt
      });
      const accountsWithUsersCount = (0, _getAccountsWithUsersCount.getAccountsWithUsersCount)({
        items
      }, tenantsUsersCountArray);
      const updatedSingleAccountViewAccounts = (0, _appendChildrenToNode.appendChildrenToNode)(selectedAccount.accounts ? selectedAccount.accounts : selectedAccount, (_payload$_subTenantId = payload == null ? void 0 : payload._subTenantId) != null ? _payload$_subTenantId : '', accountsWithUsersCount.map(account => ({
        name: account.name,
        tenantId: account.tenantId,
        numberOfUsers: account.numberOfUsers,
        createdAt: account.createdAt,
        metadata: account.metadata,
        children: [],
        loadMoreLink: _links == null ? void 0 : _links.next
      })));
      yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
        accounts: updatedSingleAccountViewAccounts
      }));
    } else {
      var _payload$_subTenantId2;
      const {
        accounts
      } = yield selectAllAccountsState();
      const {
        items,
        _links
      } = yield (0, _effects.call)(_restApi.api.tenants.searchSubTenants, searchSubTenantsQueryParams);
      const tenantsUsersCountArray = yield (0, _effects.call)(_restApi.api.tenants.getTenantsUsersCount, {
        tenantIds: items.map(i => i.tenantId)
      });
      const accountsWithUsersCount = (0, _getAccountsWithUsersCount.getAccountsWithUsersCount)({
        items
      }, tenantsUsersCountArray);
      const updatedAccounts = (0, _appendChildrenToNode.appendChildrenToNode)(accounts, (_payload$_subTenantId2 = payload == null ? void 0 : payload._subTenantId) != null ? _payload$_subTenantId2 : '', accountsWithUsersCount.map(account => ({
        name: account.name,
        tenantId: account.tenantId,
        numberOfUsers: account.numberOfUsers,
        createdAt: account.createdAt,
        metadata: account.metadata,
        children: [],
        loadMoreLink: _links == null ? void 0 : _links.next
      })));
      yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
        accounts: updatedAccounts
      }));
    }
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}
function* searchAccounts({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.SEARCH_ACCOUNTS;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    rootAccount
  } = yield selectAllAccountsState();
  const {
    jwt
  } = payload;
  try {
    if (payload != null && payload._subTenantId) {
      var _payload$_filter;
      const {
        items
      } = yield (0, _effects.call)(_restApi.api.tenants.searchSubTenants, {
        _offset: 0,
        _limit: 50,
        _filter: (_payload$_filter = payload == null ? void 0 : payload._filter) != null ? _payload$_filter : '',
        _subTenantId: payload._subTenantId
      }, {
        jwt
      });
      yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
        searchAccountsData: [...items, {
          name: rootAccount.name,
          tenantId: rootAccount.tenantId
        }]
      }));
    }
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

// when we in single account we should get new JWT for each sub-account(tenant) separately.
function* getUserJwtForSubAccount({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.GET_USER_JWT;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    tenantId,
    callback
  } = payload;
  try {
    const userJwt = yield (0, _effects.call)(_restApi.api.users.GetUserJwt, {
      tenantId
    });
    yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
      userJwt,
      accessPermission: true
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
      accessPermission: false
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}
function* createSubAccount({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.CREATE_SUB_ACCOUNT;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    name,
    parentTenantId,
    tenantId,
    jwt,
    callback
  } = payload;
  try {
    const isSelectedAccountChange = !!jwt;
    if (isSelectedAccountChange) {
      const {
        accounts
      } = yield selectAllAccountsState();
      const {
        selectedAccount
      } = yield selectAllAccountsState();
      const createdSubTenant = yield (0, _effects.call)(_restApi.api.subTenants.createSubTenant, {
        name,
        parentTenantId,
        tenantId
      }, {
        jwt
      });
      const updatedAllAccountPageAccounts = (0, _appendChildrenToNode.appendChildrenToNode)(accounts, parentTenantId != null ? parentTenantId : '', [{
        name: createdSubTenant.name,
        tenantId: createdSubTenant.tenantId,
        numberOfUsers: 0,
        createdAt: new Date()
      }]);
      const updatedSingleAccountViewAccounts = (0, _appendChildrenToNode.appendChildrenToNode)((0, _extends2.default)({
        name: '',
        tenantId: ''
      }, selectedAccount == null ? void 0 : selectedAccount.accounts), parentTenantId != null ? parentTenantId : '', [{
        name: createdSubTenant.name,
        tenantId: createdSubTenant.tenantId,
        numberOfUsers: 0,
        createdAt: new Date()
      }]);
      yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
        accounts: updatedAllAccountPageAccounts
      }));
      yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
        accounts: updatedSingleAccountViewAccounts
      }));
    } else {
      const {
        accounts
      } = yield selectAllAccountsState();
      const createdSubTenant = yield (0, _effects.call)(_restApi.api.subTenants.createSubTenant, {
        name,
        tenantId,
        parentTenantId
      });
      const updatedAccounts = (0, _appendChildrenToNode.appendChildrenToNode)(accounts, parentTenantId != null ? parentTenantId : '', [{
        name: createdSubTenant.name,
        tenantId: createdSubTenant.tenantId,
        numberOfUsers: 0,
        createdAt: new Date()
      }]);
      yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
        accounts: updatedAccounts
      }));
    }
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

// delete sub account
function* deleteSubAccount({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.DELETE_SUB_ACCOUNT;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    jwt,
    tenantId,
    callback
  } = payload;
  try {
    const isSelectedAccountChange = !!jwt;
    if (isSelectedAccountChange) {
      const {
        selectedAccount,
        accounts
      } = yield selectAllAccountsState();
      yield (0, _effects.call)(_restApi.api.subTenants.deleteSubTenant, tenantId, {
        jwt
      });
      const udpatedAccounts = (0, _removeNodeFromTree.removeNodeFromTree)(accounts, tenantId);
      const updatedAccountsForSelectedAccount = (0, _removeNodeFromTree.removeNodeFromTree)(selectedAccount == null ? void 0 : selectedAccount.accounts, tenantId);
      yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
        accounts: udpatedAccounts
      }));
      yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
        accounts: updatedAccountsForSelectedAccount
      }));
    } else {
      const {
        accounts
      } = yield selectAllAccountsState();
      yield (0, _effects.call)(_restApi.api.subTenants.deleteSubTenant, tenantId);
      const udpatedAccounts = (0, _removeNodeFromTree.removeNodeFromTree)(accounts, tenantId);
      yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
        accounts: udpatedAccounts
      }));
    }
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

//update account settings
function* updateSubAccountSettings({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.UPDATE_SUB_ACCOUNT_SETTINGS;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    jwt,
    name,
    callback,
    tenantId
  } = payload;
  try {
    const isSelectedAccountChange = !!jwt;
    if (isSelectedAccountChange) {
      const {
        selectedAccount,
        accounts
      } = yield selectAllAccountsState();
      yield (0, _effects.call)(_restApi.api.subTenants.updateSubTenant, {
        tenantId
      }, {
        name
      }, {
        jwt
      });
      const udpatedAccs = (0, _updateNodeName.updateNodeName)(selectedAccount.accounts, tenantId, name);
      yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
        name,
        accounts: udpatedAccs
      }));
      const udpatedAccsForAllAccountsPage = (0, _updateNodeName.updateNodeName)(accounts, tenantId, name);
      yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
        accounts: udpatedAccsForAllAccountsPage
      }));
    } else {
      const {
        accounts
      } = yield selectAllAccountsState();
      yield (0, _effects.call)(_restApi.api.subTenants.updateSubTenant, {
        tenantId
      }, {
        name
      });
      const udpatedAccs = (0, _updateNodeName.updateNodeName)(accounts, tenantId, name);
      yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
        accounts: udpatedAccs
      }));
    }
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

//delete user from tenants and subtenants
function* deleteUserFromAccount({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.DELETE_USERS_FROM_ACCOUNT;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    userId,
    subTenants,
    jwt,
    callback
  } = payload;
  try {
    yield (0, _effects.call)(_restApi.api.subTenants.removeUserFromTenantAndSubTenants, {
      userId,
      subTenants
    }, {
      jwt
    });
    yield (0, _effects.put)(_reducer.actions.getAccountUsers({
      jwt,
      _tenantId: subTenants[0].tenantId
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

// set/edit user roles for sub account
function* setUserRolesForSubAccount({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.SET_USER_ROLES_FOR_SUB_ACCOUNT;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    userId,
    subTenantsRoles,
    jwt,
    callback
  } = payload;
  const {
    selectedAccount
  } = yield selectAllAccountsState();
  try {
    yield (0, _effects.call)(_restApi.api.subTenants.setUserRolesForSubTenants, userId, {
      subTenantsRoles
    }, {
      jwt
    });
    yield (0, _effects.put)(_reducer.actions.getAccountUsers({
      jwt,
      _tenantId: selectedAccount.tenantId
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

// invite user to account
function* addUsersToAccount({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.ADD_USERS_TO_ACCOUNT;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    users,
    tenantId,
    jwt,
    callback,
    allowSubAccountAccess = false,
    roleIds
  } = payload;
  try {
    yield (0, _effects.call)(_restApi.api.subTenants.addUsersToSubTenant, {
      users,
      tenantId,
      allowSubAccountAccess,
      roleIds
    }, {
      jwt
    });
    yield (0, _effects.put)(_reducer.actions.getAccountUsers({
      jwt,
      _tenantId: tenantId
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

// update sub account access for user
function* updateSubAccountAccessForUser({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.UPDATE_SUB_ACCOUNT_ACCESS_FOR_USER;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    selectedAccount
  } = yield selectAllAccountsState();
  const {
    userId,
    allowAccess,
    jwt,
    callback
  } = payload;
  try {
    var _selectedAccount$user;
    yield (0, _effects.call)(_restApi.api.subTenants.updateSubAccountAccess, userId, {
      allowAccess
    }, {
      jwt
    });
    yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
      users: selectedAccount == null ? void 0 : (_selectedAccount$user = selectedAccount.users) == null ? void 0 : _selectedAccount$user.map(user => {
        if (user.id === userId) {
          return (0, _extends2.default)({}, user, {
            subAccountAccessAllowed: allowAccess
          });
        }
        return user;
      })
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

// get account users
function* getAccountUsers({
  payload
}) {
  var _ref, _payload$_offset, _allAccountsState$sel, _allAccountsState$sel2, _ref2, _payload$_limit, _allAccountsState$sel3, _allAccountsState$sel4;
  const key = _stateTypes.AllAccountsStateKeys.GET_ACCOUNT_USERS;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const allAccountsState = yield selectAllAccountsState();
  const {
    jwt,
    _tenantId,
    _email
  } = payload;
  const _offset = (_ref = (_payload$_offset = payload == null ? void 0 : payload._offset) != null ? _payload$_offset : allAccountsState == null ? void 0 : (_allAccountsState$sel = allAccountsState.selectedAccount) == null ? void 0 : (_allAccountsState$sel2 = _allAccountsState$sel.usersQueryParams) == null ? void 0 : _allAccountsState$sel2._offset) != null ? _ref : 0;
  const _limit = (_ref2 = (_payload$_limit = payload == null ? void 0 : payload._limit) != null ? _payload$_limit : allAccountsState == null ? void 0 : (_allAccountsState$sel3 = allAccountsState.selectedAccount) == null ? void 0 : (_allAccountsState$sel4 = _allAccountsState$sel3.usersQueryParams) == null ? void 0 : _allAccountsState$sel4._limit) != null ? _ref2 : 10;
  const getAccountUsersQueryParams = (0, _extends2.default)({
    _offset,
    _limit,
    _tenantId,
    _includeSubTenants: false
  }, !!_email && {
    _email
  });
  try {
    const {
      items: usersItems,
      _metadata: {
        totalItems,
        totalPages
      }
    } = yield (0, _effects.call)(_restApi.api.users.getUsersV3, getAccountUsersQueryParams, {
      jwt
    });
    const selectedAccountStateObj = {
      totalUsersItems: totalItems,
      totalUsersPages: totalPages,
      usersQueryParams: (0, _extends2.default)({
        _offset: _offset != null ? _offset : 0,
        _limit: _limit != null ? _limit : 10
      }, !!_email && {
        _email
      })
    };
    if (usersItems.length) {
      const usersIds = usersItems.map(user => user.id);
      const allRoles = yield (0, _effects.call)(_restApi.api.roles.getRoles);
      const usersRoles = yield (0, _effects.call)(_restApi.api.users.getUsersRoles, {
        ids: usersIds
      }, {
        jwt
      });
      const usersWithRoles = usersItems.map(user => {
        var _usersRoles$find, _ref3;
        const userRolesIds = usersRoles == null ? void 0 : (_usersRoles$find = usersRoles.find(role => role.userId === user.id)) == null ? void 0 : _usersRoles$find.roleIds;
        return (0, _extends2.default)({}, user, {
          roles: (_ref3 = userRolesIds == null ? void 0 : userRolesIds.map(roleId => {
            var _allRoles$find;
            return (_allRoles$find = allRoles == null ? void 0 : allRoles.find(role => role.id === roleId)) != null ? _allRoles$find : [];
          })) != null ? _ref3 : []
        });
      });
      yield (0, _effects.put)(_reducer.actions.setSelectedAccountState((0, _extends2.default)({
        users: usersWithRoles
      }, selectedAccountStateObj)));
    } else {
      yield (0, _effects.put)(_reducer.actions.setSelectedAccountState((0, _extends2.default)({
        users: []
      }, selectedAccountStateObj)));
    }
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

/**
 * Used to set selected account data.
 * name, tenantId, users, parentsAccounts, numberOfUsers, subAccountsAmount.
 * @param payload: { jwt }
 */
function* setSelectedSubAccountData({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.SET_SELECTED_SUB_ACCOUNT_DATA;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    jwt
  } = payload;
  try {
    var _accountSettings$tena, _accountSettings$tena2, _accountSettings$tena3, _subAccountsAmount$, _accountSettings$tena4, _numberOfUsersArray$, _accountSettings$tena5;
    const accountSettings = yield (0, _effects.call)(_restApi.api.accountSettings.getSettings, {
      jwt
    });
    const numberOfUsersArray = yield (0, _effects.call)(_restApi.api.tenants.getTenantsUsersCount, {
      tenantIds: [(_accountSettings$tena = accountSettings == null ? void 0 : accountSettings.tenantId) != null ? _accountSettings$tena : '']
    }, {
      jwt
    });
    const parentsAccounts = yield (0, _effects.call)(_restApi.api.tenants.getParentTenants, {
      jwt
    });
    const subAccountsAmount = yield (0, _effects.call)(_restApi.api.tenants.getHierarchyMetadata, {
      _tenantIds: [(_accountSettings$tena2 = accountSettings == null ? void 0 : accountSettings.tenantId) != null ? _accountSettings$tena2 : '']
    }, {
      jwt
    });
    yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
      tenantId: (_accountSettings$tena3 = accountSettings.tenantId) != null ? _accountSettings$tena3 : '',
      name: accountSettings.name,
      numberOfUsersObject: numberOfUsersArray[0],
      parentsAccounts,
      numberOfSubAccounts: (_subAccountsAmount$ = subAccountsAmount[0]) == null ? void 0 : _subAccountsAmount$.totalSubTenants,
      accountSettings,
      accounts: {
        name: accountSettings.name,
        tenantId: (_accountSettings$tena4 = accountSettings.tenantId) != null ? _accountSettings$tena4 : '',
        numberOfUsers: (_numberOfUsersArray$ = numberOfUsersArray[0]) == null ? void 0 : _numberOfUsersArray$.totalUsers,
        //Not implemented on backend yet
        createdAt: undefined,
        children: []
      }
    }));
    yield (0, _effects.put)(_reducer.actions.getAccountUsers({
      jwt,
      _tenantId: (_accountSettings$tena5 = accountSettings == null ? void 0 : accountSettings.tenantId) != null ? _accountSettings$tena5 : ''
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}

/**
 * Used to set root account data.
 */
function* setRootAccountData() {
  const key = _stateTypes.AllAccountsStateKeys.SET_ROOT_ACCOUNT_DATA;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    activeTenant
  } = yield selectTenantsState();
  const {
    accounts
  } = yield selectAllAccountsState();
  if (!activeTenant) return;
  try {
    var _tenantUsersCount$;
    const tenantUsersCount = yield (0, _effects.call)(_restApi.api.tenants.getTenantsUsersCount, {
      tenantIds: [activeTenant == null ? void 0 : activeTenant.tenantId]
    });
    const rootAccount = {
      name: activeTenant == null ? void 0 : activeTenant.name,
      tenantId: activeTenant == null ? void 0 : activeTenant.tenantId,
      numberOfUsers: (_tenantUsersCount$ = tenantUsersCount[0]) == null ? void 0 : _tenantUsersCount$.totalUsers,
      createdAt: activeTenant == null ? void 0 : activeTenant.createdAt
    };
    yield (0, _effects.put)(_reducer.actions.setAllAccountsState({
      rootAccount,
      accounts: (0, _extends2.default)({}, accounts, rootAccount)
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}
function* loadNumberOfUsersForSelectedSubAccount({
  payload
}) {
  const key = _stateTypes.AllAccountsStateKeys.LOAD_NUMBER_OF_USERS_FOR_ACCOUNT;
  yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
    key,
    value: true
  }));
  const {
    tenantId,
    jwt
  } = payload;
  try {
    const numberOfUsersArray = yield (0, _effects.call)(_restApi.api.tenants.getTenantsUsersCount, {
      tenantIds: [tenantId]
    }, {
      jwt
    });
    yield (0, _effects.put)(_reducer.actions.setSelectedAccountState({
      numberOfUsersObject: numberOfUsersArray[0]
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsError({
      key,
      value: (0, _utils.errorHandler)(e)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setAllAccountsLoader({
      key,
      value: false
    }));
  }
}
function* allAccountsSagas() {
  yield (0, _effects.takeLatest)(_reducer.actions.loadAccounts, loadAccounts);
  yield (0, _effects.takeLatest)(_reducer.actions.searchAccounts, searchAccounts);
  yield (0, _effects.takeLatest)(_reducer.actions.updateSubAccountAccessForUser, updateSubAccountAccessForUser);
  yield (0, _effects.takeLatest)(_reducer.actions.getUserJwtForSubAccount, getUserJwtForSubAccount);
  yield (0, _effects.takeLatest)(_reducer.actions.createSubAccount, createSubAccount);
  yield (0, _effects.takeLatest)(_reducer.actions.deleteSubAccount, deleteSubAccount);
  yield (0, _effects.takeLatest)(_reducer.actions.updateSubAccountSettings, updateSubAccountSettings);
  yield (0, _effects.takeLatest)(_reducer.actions.addUsersToAccount, addUsersToAccount);
  yield (0, _effects.takeLatest)(_reducer.actions.deleteUsersFromAccount, deleteUserFromAccount);
  yield (0, _effects.takeLatest)(_reducer.actions.setUserRolesForSubAccount, setUserRolesForSubAccount);
  yield (0, _effects.takeLatest)(_reducer.actions.getAccountUsers, getAccountUsers);
  yield (0, _effects.takeLatest)(_reducer.actions.setRootAccountData, setRootAccountData);
  yield (0, _effects.takeLatest)(_reducer.actions.setSelectedSubAccountData, setSelectedSubAccountData);
  yield (0, _effects.takeLatest)(_reducer.actions.loadNumberOfUsersForSelectedSubAccount, loadNumberOfUsersForSelectedSubAccount);
}