"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "afterAuthNavigation", {
  enumerable: true,
  get: function () {
    return _afterAuthNavigation.afterAuthNavigation;
  }
});
exports.loadSSOPublicConfigurationFunction = loadSSOPublicConfigurationFunction;
exports.loginSagas = loginSagas;
exports.loginSagasMock = loginSagasMock;
Object.defineProperty(exports, "mfaWithAuthenticator", {
  enumerable: true,
  get: function () {
    return _mfaWithAuthenticator.mfaWithAuthenticator;
  }
});
exports.refreshMetadata = refreshMetadata;
exports.refreshToken = refreshToken;
exports.refreshTokenForSocialLogins = refreshTokenForSocialLogins;
exports.requestHostedLoginAuthorize = requestHostedLoginAuthorize;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _effects = require("redux-saga/effects");
var _restApi = require("@frontegg/rest-api");
var _reducer = require("../reducer");
var _constants = require("../../constants");
var _interfaces = require("../interfaces");
var _interfaces2 = require("./interfaces");
var _mfaRequiredState = require("./sagas/mfaRequiredState.saga");
var _saga = require("../SignUp/saga");
var _interfaces3 = require("../MfaState/interfaces");
var _dummy = require("../dummy");
var _interfaces4 = require("../SSOState/interfaces");
var _saga2 = require("../../vendor/saga");
var _helpers = require("../../helpers");
var _utils = require("../utils");
var _saga3 = require("../Security/SecurityPolicyState/saga");
var _utils2 = require("./utils");
var _utils3 = require("../../utils");
var _consts = require("./consts");
var _Entitlements = require("../Entitlements");
var _saga4 = require("../CustomLoginState/saga");
var _toolkit = require("../../toolkit");
var _saga5 = require("./saga.utils");
var _utils4 = require("../StepUpState/utils");
var _sagas = require("./sagas");
var _consts2 = require("../StepUpState/consts");
var _afterAuthNavigation = require("./sagas/afterAuthNavigation.saga");
var _mfaWithAuthenticator = require("./sagas/mfaWithAuthenticator.saga");
const _excluded = ["callback"],
  _excluded2 = ["callback"],
  _excluded3 = ["callback"],
  _excluded4 = ["callback"],
  _excluded5 = ["callback", "events"],
  _excluded6 = ["callback"],
  _excluded7 = ["callback"],
  _excluded8 = ["callback"],
  _excluded9 = ["callback"],
  _excluded10 = ["user"],
  _excluded11 = ["callback"],
  _excluded12 = ["callback"],
  _excluded13 = ["callback"],
  _excluded14 = ["callback"],
  _excluded15 = ["callback"];
/******************************************************************
 ***                                                             ****
 *** PLEASE DO NOT ADD CODE TO THIS FILE                         ****
 *** NEW SAGAS - ADD AS A NEW FILE IN THE SAGAS FOLDER           ****
 *** EXISTING SAGAS - MOVE TO THE SAGAS FOLDER WHEN TOUCHING IT  ****
 ***                                                             ****
 *******************************************************************/

/**
 * Prevent unnecessary entitlements reference update inside the user object by
 * deep equality with the stored user.entitlements
 * This function should not be used for first login because no stored entitlements.
 * @param updatedUser new user response from the BE
 * @returns final user object with the correct entitlements reference
 */
function* handleUnnecessaryEntitlementsUpdate(updatedUser) {
  const oldEntitlements = yield (0, _effects.select)(state => {
    var _state$auth$user;
    return (_state$auth$user = state.auth.user) == null ? void 0 : _state$auth$user.entitlements;
  });
  if ((0, _Entitlements.isEntitlementsDeeplyEqual)(oldEntitlements, updatedUser == null ? void 0 : updatedUser.entitlements)) {
    // set the previous entitlemenets object
    return (0, _extends2.default)({}, updatedUser, {
      entitlements: oldEntitlements
    });
  }
  return updatedUser;
}
function* refreshMetadata() {
  let ssoACS;
  try {
    var _metadata$configurati;
    const metadata = yield (0, _effects.call)(_restApi.api.metadata.getSamlMetadata);
    ssoACS = metadata == null ? void 0 : (_metadata$configurati = metadata.configuration) == null ? void 0 : _metadata$configurati.acsUrl;
  } catch (e) {
    console.error(e);
  }
  yield (0, _effects.put)(_reducer.actions.setState({
    ssoACS
  }));
}
function* loadSSOPublicConfigurationFunction() {
  try {
    const {
      isActive
    } = yield (0, _effects.call)(_restApi.api.auth.getSSOPublicConfiguration);
    yield (0, _effects.put)(_reducer.actions.setState({
      isSSOAuth: isActive
    }));
  } catch (e) {
    console.error(e);
  }
}
function* shouldNevigateToRegisterQuickLogin(user) {
  var _ref;
  const {
    routes,
    loginState
  } = yield (0, _effects.select)(state => state.auth);
  const quickLoginToRegister = (_ref = localStorage.getItem('register-quick-login')) != null ? _ref : loginState.quickLoginToRegister;
  return quickLoginToRegister && localStorage.getItem(`${user.id}-${quickLoginToRegister}`) !== 'true' && !window.location.pathname.endsWith(routes.logoutUrl);
}
function* refreshToken() {
  const {
    hostedLoginBox
  } = yield (0, _effects.select)(state => state.auth);
  if (hostedLoginBox) {
    yield (0, _effects.call)(refreshTokenHosted);
  } else {
    yield (0, _effects.call)(refreshTokenEmbedded);
  }
}
function* refreshTokenForSocialLogins() {
  const {
    hostedLoginBox
  } = yield (0, _effects.select)(state => state.auth);
  if (hostedLoginBox) {
    yield (0, _effects.call)(refreshTokenHostedSocialLogins);
  } else {
    yield (0, _effects.call)(refreshTokenEmbeddedSocialLogins);
  }
}
function* refreshTokenHosted() {
  const {
    user
  } = yield (0, _effects.select)(state => state.auth);
  if (!(user != null && user.refreshToken)) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    yield (0, _effects.put)(_reducer.actions.setState({
      user: null,
      isAuthenticated: false
    }));
    return;
  }
  try {
    const body = {
      grant_type: 'refresh_token',
      refresh_token: user == null ? void 0 : user.refreshToken
    };
    const response = yield (0, _effects.call)(_restApi.api.auth.exchangeOAuthTokensV2, body);
    const updatedUser = yield (0, _effects.call)(handleUnnecessaryEntitlementsUpdate, response.user);
    yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, (0, _extends2.default)({}, response, {
      user: updatedUser
    }), {
      isAuthenticated: true
    });
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    yield (0, _effects.put)(_reducer.actions.setState({
      user: null,
      isAuthenticated: false
    }));
  }
}
function* refreshTokenHostedSocialLogins() {
  const {
    user: currentUser
  } = yield (0, _effects.select)(state => state.auth);
  if (!(currentUser != null && currentUser.refreshToken)) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    yield (0, _effects.put)(_reducer.actions.setState({
      user: null,
      isAuthenticated: false
    }));
    return;
  }
  try {
    const body = {
      grant_type: 'refresh_token',
      refresh_token: currentUser == null ? void 0 : currentUser.refreshToken
    };
    const response = yield (0, _effects.call)(_restApi.api.auth.exchangeOAuthTokensV2, body);
    const updatedUser = yield (0, _effects.call)(handleUnnecessaryEntitlementsUpdate, response.user);
    yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, (0, _extends2.default)({}, response, {
      user: updatedUser
    }), {
      isAuthenticated: true
    });
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    yield (0, _effects.put)(_reducer.actions.setState({
      user: null,
      isAuthenticated: false
    }));
  }
}
function* refreshTokenEmbedded() {
  try {
    const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
    const {
      routes,
      loginState
    } = yield (0, _effects.select)(state => state.auth);
    const {
      user,
      tenants = [],
      activeTenant
    } = yield (0, _effects.call)(_restApi.api.auth.refreshTokenV3);
    if ((0, _utils2.isMfaRequired)(user)) {
      const mfaRequiredState = yield (0, _mfaRequiredState.getMfaRequiredState)(user);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      var _ref2;
      if (user.id) {
        localStorage.setItem('userId', user.id);
      }
      const quickLoginToRegister = (_ref2 = localStorage.getItem('register-quick-login')) != null ? _ref2 : loginState.quickLoginToRegister;
      const shouldNavigateToRegisterQuickLogin = yield shouldNevigateToRegisterQuickLogin(user);
      const updatedUser = yield (0, _effects.call)(handleUnnecessaryEntitlementsUpdate, user);
      yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, {
        user: updatedUser,
        tenants,
        activeTenant
      }, {
        loginState: (0, _extends2.default)({}, loginState, {
          quickLoginToRegister,
          flow: shouldNavigateToRegisterQuickLogin ? _interfaces2.LoginFlow.RegisterQuickLogin : _interfaces2.LoginFlow.Login
        }),
        isAuthenticated: true
      });
      yield handleRedirectRefreshToken(shouldNavigateToRegisterQuickLogin);
    }
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    yield (0, _effects.put)(_reducer.actions.setState({
      user: undefined,
      isAuthenticated: false
    }));
  }
}
function* refreshTokenEmbeddedSocialLogins() {
  try {
    const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
    const {
      routes,
      loginState
    } = yield (0, _effects.select)(state => state.auth);
    const {
      user,
      tenants = [],
      activeTenant
    } = yield (0, _effects.call)(_restApi.api.auth.refreshTokenV3);
    if ((0, _utils2.isMfaRequired)(user)) {
      const mfaRequiredState = yield (0, _mfaRequiredState.getMfaRequiredState)(user);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      const updatedUser = yield (0, _effects.call)(handleUnnecessaryEntitlementsUpdate, user);
      const shouldShowPrompt = yield (0, _effects.call)(_saga5.shouldShowPromptPasskeys);
      if (shouldShowPrompt) {
        yield (0, _effects.put)(_reducer.actions.setLoginState({
          step: _interfaces2.LoginStep.promptPasskeys,
          loading: false
        }));
        yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, {
          user: updatedUser,
          tenants,
          activeTenant
        }, {
          isLoading: false
        });
        onRedirectTo(routes.loginUrl, {
          preserveQueryParams: true
        });
      } else {
        var _ref3;
        if (user.id) {
          localStorage.setItem('userId', user.id);
        }
        const quickLoginToRegister = (_ref3 = localStorage.getItem('register-quick-login')) != null ? _ref3 : loginState.quickLoginToRegister;
        const shouldNavigateToRegisterQuickLogin = yield shouldNevigateToRegisterQuickLogin(user);
        yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, {
          user: updatedUser,
          tenants,
          activeTenant
        }, {
          loginState: (0, _extends2.default)({}, loginState, {
            quickLoginToRegister,
            flow: shouldNavigateToRegisterQuickLogin ? _interfaces2.LoginFlow.RegisterQuickLogin : _interfaces2.LoginFlow.Login
          }),
          isAuthenticated: true
        });
        yield handleRedirectRefreshToken(shouldNavigateToRegisterQuickLogin);
      }
    }
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    yield (0, _effects.put)(_reducer.actions.setState({
      user: undefined,
      isAuthenticated: false
    }));
  }
}
function* handleRedirectRefreshToken(shouldNavigateToRegisterQuickLogin) {
  var _window;
  const url = new URL((_window = window) == null ? void 0 : _window.location.href);
  const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
  const {
    routes,
    loginState
  } = yield (0, _effects.select)(state => state.auth);
  const invitationToken = url.searchParams.get('invitationToken');
  const redirectRoutes = [routes.socialLoginCallbackUrl, routes.oidcRedirectUrl, routes.samlCallbackUrl];
  if (!invitationToken) {
    redirectRoutes.push(routes.loginUrl, routes.signUpUrl);
  }
  if (shouldNavigateToRegisterQuickLogin) {
    onRedirectTo(routes.loginUrl);
  } else if (redirectRoutes.some(url => url && window.location.pathname.endsWith(url))) {
    if (loginState.isNewUser && routes.signUpSuccessUrl && routes.socialLoginCallbackUrl === window.location.pathname) {
      onRedirectTo(routes.signUpSuccessUrl, {
        refresh: routes.signUpSuccessUrl.startsWith('http')
      });
    } else {
      yield (0, _sagas.afterAuthNavigation)();
    }
  }
}
function* getUserIP({
  payload: {
    callback
  }
}) {
  try {
    const {
      ip
    } = yield (0, _effects.call)(_restApi.api.metadata.getCurrentUserIpMetadata);
    yield (0, _effects.put)(_reducer.actions.setState({
      userIp: ip
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    callback == null ? void 0 : callback(false);
  }
}
function* requestAuthorize({
  payload: firstTime
}) {
  const calls = [];
  const callsAfterRefresh = [];
  calls.push((0, _effects.call)(refreshToken));
  if (firstTime) {
    yield (0, _effects.put)(_reducer.actions.setState({
      isLoading: true
    }));
    yield (0, _effects.put)(_reducer.actions.loadSocialLoginsConfigurationV2());
    calls.push((0, _effects.call)(_saga.loadAllowSignUps));
    calls.push((0, _effects.call)(_saga3.loadPublicAuthStrategiesPolicy));
    calls.push((0, _effects.call)(loadSSOPublicConfigurationFunction));
    calls.push((0, _effects.call)(_saga2.loadVendorPublicInfo));
    calls.push((0, _effects.call)(refreshMetadata));
    /*
      We will load custom login routes only if custom login is enabled
      In order to check if custom login is enabled without the tenant alias (search-param/sub-domain)
      we have to wait for the user state (refreshToken request)
    */
    callsAfterRefresh.push((0, _effects.call)(_saga4.loadCustomLoginRoutes));
  }
  yield (0, _effects.all)(calls);
  if (callsAfterRefresh.length > 0) {
    yield (0, _effects.all)(callsAfterRefresh);
  }
  yield (0, _effects.put)(_reducer.actions.setState({
    isLoading: false
  }));
}
function* isMFARequiredSSR({
  accessToken,
  user
}) {
  if (!accessToken) {
    yield (0, _effects.put)(_reducer.actions.setState({
      user: undefined,
      isAuthenticated: false
    }));
    return;
  }
  const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
  const {
    routes
  } = yield (0, _effects.select)(state => state.auth);
  if ((0, _utils2.isMfaRequired)(user)) {
    const mfaRequiredState = yield (0, _mfaRequiredState.getMfaRequiredState)(user);
    yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
    onRedirectTo(routes.loginUrl, {
      preserveQueryParams: true
    });
  }
}
function* requestAuthorizeSSR({
  payload
}) {
  const calls = [];
  yield (0, _effects.put)(_reducer.actions.loadSocialLoginsConfigurationV2());
  calls.push((0, _effects.call)(_saga.loadAllowSignUps));
  calls.push((0, _effects.call)(loadSSOPublicConfigurationFunction));
  calls.push((0, _effects.call)(_saga2.loadVendorPublicInfo));
  calls.push((0, _effects.call)(refreshMetadata));
  calls.push((0, _effects.call)(isMFARequiredSSR, payload));
  calls.push((0, _effects.call)(_saga4.loadCustomLoginRoutes));
  yield (0, _effects.all)(calls);
}
const getUri = urlStrategy => {
  if (urlStrategy === 'path') {
    var _window2;
    return ((_window2 = window) != null ? _window2 : document).location.pathname;
  } else {
    var _window3;
    const uri = (((_window3 = window) != null ? _window3 : document).location.hash || '#').substring(1);
    if (uri.indexOf('?') !== -1) {
      return uri.substring(0, uri.indexOf('?'));
    } else {
      return uri;
    }
  }
};
function* requestHostedLoginSilentAuthorize() {
  const response = yield (0, _effects.call)(_restApi.api.auth.silentOAuthRefreshTokenV2);
  if (response != null && response.user) {
    yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, response, {
      isAuthenticated: true,
      isLoading: false
    });
  } else {
    throw new Error(`couldn't refresh user token with oauth service`);
  }
}
function* refreshOrRequestHostedLoginAuthorize({
  payload: additionalParams
}) {
  var _localStorage;
  // when the user pause the step up flow we may still have the key in the local storage in hosted - Remove it
  (_localStorage = localStorage) == null ? void 0 : _localStorage.removeItem(_consts2.SHOULD_STEP_UP_KEY);
  const {
    disableSilentRefresh
  } = yield (0, _effects.select)(state => ({
    disableSilentRefresh: state.auth.disableSilentRefresh
  }));
  if ((additionalParams == null ? void 0 : additionalParams.prompt) === 'login') {
    yield requestHostedLoginAuthorize(additionalParams);
    return;
  }
  try {
    if (disableSilentRefresh) {
      throw new Error('silent refresh is disabled');
    }
    yield requestHostedLoginSilentAuthorize();
  } catch (e) {
    yield requestHostedLoginAuthorize(additionalParams);
  }
}
function* refreshOrRequestHostedLoginAuthorizeV2({
  payload: {
    additionalParams,
    shouldRedirectToLogin,
    firstTime,
    loginDirectAction
  }
}) {
  var _localStorage2, _additionalParams;
  // when the user pause the step up flow we may still have the key in the local storage in hosted - Remove it
  (_localStorage2 = localStorage) == null ? void 0 : _localStorage2.removeItem(_consts2.SHOULD_STEP_UP_KEY);
  if (firstTime) {
    const {
      urlStrategy
    } = yield (0, _effects.select)(state => ({
      urlStrategy: state.root.urlStrategy
    }));
    const activeUri = getUri(urlStrategy);
    yield (0, _effects.put)(_reducer.actions.setState({
      isLoading: true
    }));
    if ((0, _utils2.isOauthCallbackRoute)(activeUri)) {
      return;
    }
  }
  const {
    disableSilentRefresh
  } = yield (0, _effects.select)(state => ({
    disableSilentRefresh: state.auth.disableSilentRefresh
  }));
  if (loginDirectAction) {
    additionalParams = additionalParams || {};
    additionalParams['login_direct_action'] = btoa(JSON.stringify(loginDirectAction));
  }
  if (((_additionalParams = additionalParams) == null ? void 0 : _additionalParams.prompt) === 'login') {
    yield requestHostedLoginAuthorize(additionalParams);
    return;
  }
  try {
    if (disableSilentRefresh) {
      throw new Error('silent refresh is disabled');
    }
    yield requestHostedLoginSilentAuthorize();
  } catch (e) {
    if (!shouldRedirectToLogin) {
      yield (0, _effects.put)(_reducer.actions.setState({
        isLoading: false
      }));
      return;
    }
    yield requestHostedLoginAuthorize(additionalParams);
  }
}
function* requestHostedLoginAuthorize(additionalParams) {
  const {
    routes,
    context,
    onRedirectTo,
    urlStrategy
  } = yield (0, _effects.select)(state => ({
    routes: state.auth.routes,
    onRedirectTo: state.auth.onRedirectTo,
    context: state.root.context,
    urlStrategy: state.root.urlStrategy
  }));
  const activeUri = getUri(urlStrategy);
  if (activeUri === routes.hostedLoginRedirectUrl) {
    console.debug('Calling loginWithRedirect while in hostedLoginCallback route');
    return;
  }
  yield (0, _effects.put)(_reducer.actions.setState({
    isLoading: true
  }));
  // Generate the relevant params for the redirect
  const nonce = (0, _helpers.createRandomString)();
  const code_verifier = (0, _helpers.createRandomString)();
  const code_challenge = yield (0, _effects.call)(_helpers.generateCodeChallenge, code_verifier);

  // We are saving the verifier in session storage to be able to validate the response
  localStorage.setItem(_constants.HOSTED_LOGIN_VERIFIER_KEY, code_verifier);
  let redirectUrl = `${window.location.origin}${urlStrategy === 'path' ? '' : '#'}${routes.hostedLoginRedirectUrl}`;
  yield (0, _effects.call)(_saga4.loadCustomLoginRoutes);
  const customLoginSearchParam = yield (0, _effects.select)(state => {
    var _state$auth$customLog;
    return (_state$auth$customLog = state.auth.customLoginState) == null ? void 0 : _state$auth$customLog.customLoginSearchParams;
  });
  if (customLoginSearchParam) {
    if (redirectUrl.endsWith('/')) {
      redirectUrl = redirectUrl.slice(0, -1);
    }
    redirectUrl += customLoginSearchParam;
  }
  const baseUrl = _restApi.fetch.getBaseUrl(context, '/oauth/authorize');
  // Hard coded for now
  const oauthUrl = `${baseUrl}/oauth/authorize`;
  const params = (0, _extends2.default)({
    response_type: 'code',
    client_id: context.clientId || 'INVALID-CLIENT-ID',
    scope: 'openid email profile',
    redirect_uri: redirectUrl,
    code_challenge: code_challenge,
    code_challenge_method: 'S256',
    nonce
  }, additionalParams);
  if (!(additionalParams != null && additionalParams.organization)) {
    const customLoginAlias = yield (0, _effects.call)(_saga4.getCustomLoginAlias);
    if (customLoginAlias) {
      params['organization'] = customLoginAlias;
    }
  }
  const tenantId = (0, _utils2.getSearchParam)(_utils2.TENANT_ID_PARAM_KEY);
  if (tenantId) {
    params['tenantId'] = tenantId;
  }
  const searchParams = new URLSearchParams(params);
  const url = `${oauthUrl}?${searchParams.toString()}`;
  onRedirectTo(url, {
    refresh: true
  });
}
function* handleHostedLoginCallback({
  payload
}) {
  // Hard coded for now
  const code_verifier = localStorage.getItem(_constants.HOSTED_LOGIN_VERIFIER_KEY) || 'INVALID-CODE-VERIFIER';
  const {
    routes,
    urlStrategy
  } = yield (0, _effects.select)(state => ({
    routes: state.auth.routes,
    urlStrategy: state.root.urlStrategy
  }));
  let redirectUrl = `${window.location.origin}${urlStrategy === 'path' ? '' : '#'}${routes.hostedLoginRedirectUrl}`;
  yield (0, _effects.call)(_saga4.loadCustomLoginRoutes);
  const customLoginSearchParam = yield (0, _effects.select)(state => {
    var _state$auth$customLog2;
    return (_state$auth$customLog2 = state.auth.customLoginState) == null ? void 0 : _state$auth$customLog2.customLoginSearchParams;
  });
  if (customLoginSearchParam) {
    if (redirectUrl.endsWith('/')) {
      redirectUrl = redirectUrl.slice(0, -1);
    }
    redirectUrl += customLoginSearchParam;
  }
  const body = {
    code: payload.code,
    redirect_uri: redirectUrl,
    code_verifier,
    grant_type: 'authorization_code'
  };
  try {
    const response = yield (0, _effects.call)(_restApi.api.auth.exchangeOAuthTokensV2, body);
    yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, response, {
      isAuthenticated: true,
      isLoading: false
    });
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setState({
      isLoading: false
    }));
    console.error('Failed to exchangeOAuthTokens', e);
  } finally {
    const user = yield (0, _effects.select)(({
      auth
    }) => auth.user);
    const isStepUpFlow = window.localStorage.getItem(_consts2.SHOULD_STEP_UP_KEY);
    window.localStorage.removeItem(_consts2.SHOULD_STEP_UP_KEY);

    // when the user pause the step up flow we may still have the key in the local storage in hosted. Ignore it.
    if (isStepUpFlow && (0, _utils4.isSteppedUp)(user)) {
      yield (0, _sagas.afterStepUpAuthNavigation)();
    } else {
      yield (0, _sagas.afterAuthNavigation)();
    }
  }
}
function* changePhoneNumberWithVerification(_ref4) {
  let {
      payload: {
        callback
      }
    } = _ref4,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref4.payload, _excluded);
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const changePhoneRes = yield (0, _effects.call)(_restApi.api.auth.changePhoneNumberWithVerification, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      phoneNumber: payload.phoneNumber,
      loading: false,
      changePhoneId: changePhoneRes.changePhoneId,
      step: _interfaces2.LoginStep.loginWithQuickSmsOtc,
      error: undefined
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e),
      loading: false
    }));
  }
}
function* verifyChangePhoneNumber(_ref5) {
  let {
      payload: {
        callback
      }
    } = _ref5,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref5.payload, _excluded2);
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    yield (0, _effects.call)(_restApi.api.auth.verifyChangePhoneNumber, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e),
      loading: false
    }));
  }
}
function* quickSmsPasswordlessPreLogin(_ref6) {
  let {
      payload: {
        callback
      }
    } = _ref6,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref6.payload, _excluded3);
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));

    // TODO: [Typescript 4.8] fix @frontegg/rest-api return value
    // @ts-ignore
    const preloginRes = yield (0, _effects.call)(_restApi.api.auth.passwordlessPreLogin, (0, _extends2.default)({}, payload, {
      type: _restApi.AuthStrategyEnum.SmsCode
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithQuickSmsOtc,
      loading: false,
      phoneNumber: preloginRes == null ? void 0 : preloginRes.phoneNumber,
      error: undefined
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e),
      loading: false
    }));
    callback == null ? void 0 : callback(e);
  }
}
function* passwordlessPreLogin(_ref7) {
  let {
      payload: {
        callback
      }
    } = _ref7,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref7.payload, _excluded4);
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    let email;
    if ((0, _utils2.isEmailPayload)(payload)) {
      email = payload.email;
    }

    // TODO: [Typescript 4.8] fix @frontegg/rest-api return value
    // @ts-ignore
    const preloginRes = yield (0, _effects.call)(_restApi.api.auth.passwordlessPreLogin, payload);
    const step = _consts.authStrategyLoginStepMap[payload.type];
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step,
      loading: false,
      phoneNumber: preloginRes == null ? void 0 : preloginRes.phoneNumber,
      email,
      error: undefined
    }));
    callback == null ? void 0 : callback();
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e),
      loading: false
    }));
    callback == null ? void 0 : callback();
  }
}
function* passwordlessPostLogin(_ref8) {
  let {
      payload: {
        callback,
        events
      }
    } = _ref8,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref8.payload, _excluded5);
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const {
      user,
      tenants = [],
      activeTenant
    } = yield (0, _effects.call)(_restApi.api.auth.passwordlessPostLoginV2, payload);
    const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
    const {
      routes
    } = yield (0, _effects.select)(state => state.auth);
    if ((0, _utils2.isMfaRequired)(user)) {
      const mfaRequiredState = yield (0, _mfaRequiredState.getMfaRequiredState)(user);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      const {
        loginState
      } = yield (0, _effects.select)(state => state.auth);
      if (user.emailVerified) {
        var _events$userVerified;
        const userVerifiedPayload = {
          email: user.email,
          origin: _interfaces.UserVeirifedOriginTypes.PASSWORDLESS,
          id: user.id,
          tenantId: user.tenantId,
          createdAt: new Date(),
          name: user.name
        };
        events == null ? void 0 : (_events$userVerified = events.userVerified) == null ? void 0 : _events$userVerified.call(events, userVerifiedPayload);
        (0, _utils3.reportGTMEvent)(_utils3.GTMEventAction.USER_VERIFIED, userVerifiedPayload);
      }
      if (user.id) {
        localStorage.setItem('userId', user.id);
      }
      yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, {
        user,
        tenants,
        activeTenant
      });
      yield (0, _effects.put)(_reducer.actions.setLoginState({
        error: undefined
      }));
      yield (0, _effects.put)(_reducer.actions.setState({
        isLoading: false
      }));
      if (loginState.flow === _interfaces2.LoginFlow.Login) {
        const shouldShowPrompt = yield (0, _effects.call)(_saga5.shouldShowPromptPasskeys);
        if (shouldShowPrompt) {
          yield (0, _effects.put)(_reducer.actions.setLoginState({
            step: _interfaces2.LoginStep.promptPasskeys,
            loading: false
          }));
          onRedirectTo(routes.loginUrl, {
            preserveQueryParams: true
          });
        } else {
          yield (0, _effects.put)(_reducer.actions.setState({
            isAuthenticated: true
          }));
          yield (0, _sagas.afterAuthNavigation)();
        }
      } else {
        onRedirectTo(routes.loginUrl, {
          preserveQueryParams: true
        });
      }
      localStorage.removeItem('register-quick-login');
      callback == null ? void 0 : callback(true);
    }
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e, 'Failed to authenticate')
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}
function* verifyInviteToken({
  payload
}) {
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const {
      name: inviteTokenTenantName
    } = yield (0, _effects.call)(_restApi.api.auth.verifyInviteToken, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      inviteTokenTenantName
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      inviteTokenError: (0, _utils3.errorHandler)(e, `We couldn't verify your invitation`)
    }));
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}
function* preLogin({
  payload: {
    email,
    recaptchaToken,
    invitationToken,
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    const onRedirectTo = yield (0, _effects.select)(({
      auth: {
        onRedirectTo
      }
    }) => onRedirectTo);
    const tenantId = (0, _utils2.getSearchParam)(_utils2.TENANT_ID_PARAM_KEY);
    const {
      address,
      idpType
    } = yield (0, _effects.call)(_restApi.api.auth.preLoginV2, {
      email,
      tenantId
    });
    if (address) {
      let ssoRedirectUrl = address;
      if (idpType === _interfaces4.SamlVendors.Oidc && !ssoRedirectUrl.includes('redirect_uri')) {
        const {
          routes: {
            oidcRedirectUrl
          }
        } = yield (0, _effects.select)(({
          auth: {
            routes
          }
        }) => ({
          routes
        }));
        ssoRedirectUrl += `&redirect_uri=${window.location.origin}${oidcRedirectUrl}`;
      }
      if (_toolkit.FronteggNativeModule.isAvailable('loginWithSSO')) {
        _toolkit.FronteggNativeModule.loginWithSSO(email);
        yield (0, _effects.put)(_reducer.actions.setLoginState({
          loading: false
        }));
        callback == null ? void 0 : callback();
      } else {
        yield (0, _effects.put)(_reducer.actions.setLoginState({
          step: _interfaces2.LoginStep.redirectToSSO,
          loading: false,
          ssoRedirectUrl
        }));
        setTimeout(() => {
          onRedirectTo(ssoRedirectUrl, {
            refresh: true
          });
        }, 2000);
      }
    } else {
      yield ssoPreloginFailed({
        email,
        recaptchaToken,
        callback,
        invitationToken
      });
    }
  } catch (e) {
    yield ssoPreloginFailed({
      email,
      recaptchaToken,
      callback,
      invitationToken
    });
  }
}
function* ssoPreloginFailed(_ref9) {
  let {
      callback
    } = _ref9,
    body = (0, _objectWithoutPropertiesLoose2.default)(_ref9, _excluded6);
  const publicPolicy = yield (0, _effects.select)(({
    auth: {
      securityPolicyState: {
        publicPolicy: {
          policy: publicPolicy
        }
      }
    }
  }) => publicPolicy);
  if (!(publicPolicy != null && publicPolicy.authStrategy)) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithPassword,
      loading: false
    }));
    callback == null ? void 0 : callback();
    return;
  }
  if ((publicPolicy == null ? void 0 : publicPolicy.authStrategy) === _restApi.AuthStrategyEnum.EmailAndPassword) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithPassword,
      loading: false
    }));
    callback == null ? void 0 : callback();
  } else if ([_restApi.AuthStrategyEnum.MagicLink, _restApi.AuthStrategyEnum.Code, _restApi.AuthStrategyEnum.SmsCode].includes(publicPolicy == null ? void 0 : publicPolicy.authStrategy)) {
    yield (0, _effects.put)(_reducer.actions.passwordlessPreLogin((0, _extends2.default)({}, body, {
      type: publicPolicy == null ? void 0 : publicPolicy.authStrategy,
      callback
    })));
  } else {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithPassword,
      loading: false
    }));
    callback == null ? void 0 : callback();
  }
}
function* webAuthnCreateNewDeviceSession({
  payload: {
    callback
  }
}) {
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const {
      options
    } = yield (0, _effects.call)(_restApi.api.auth.webAuthnCreateNewDeviceSession);
    options.user.id = (0, _utils.base64urlDecode)(options.user.id);
    options.challenge = (0, _utils.base64urlDecode)(options.challenge);
    options.excludeCredentials = [];
    callback == null ? void 0 : callback(options);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}
function* webAuthnVerifyNewDeviceSession(_ref10) {
  let {
      payload: {
        callback
      }
    } = _ref10,
    body = (0, _objectWithoutPropertiesLoose2.default)(_ref10.payload, _excluded7);
  try {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const publicKey = (0, _utils.publicKeyCredentialToJSON)(body.publicKey);
    const deviceType = (publicKey == null ? void 0 : publicKey.authenticatorAttachment) === 'platform' ? _restApi.WebAuthnDeviceType.Platform : _restApi.WebAuthnDeviceType.CrossPlatform;
    yield (0, _effects.call)(_restApi.api.auth.verifyNewDeviceSession, {
      id: publicKey.id,
      response: publicKey.response,
      deviceType: deviceType
    });
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}
function* webAuthnPrelogin(_ref11) {
  let {
      payload: {
        callback
      }
    } = _ref11,
    body = (0, _objectWithoutPropertiesLoose2.default)(_ref11.payload, _excluded8);
  try {
    var _options$allowCredent;
    yield (0, _effects.put)(_reducer.actions.setPasskeysState({
      loading: true
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const {
      options
    } = yield (0, _effects.call)(_restApi.api.auth.webAuthnPreLogin, body);
    options.challenge = (0, _utils.base64urlDecode)(options.challenge);
    options.allowCredentials = (_options$allowCredent = options.allowCredentials) == null ? void 0 : _options$allowCredent.map(credentials => (0, _extends2.default)({}, credentials, {
      id: (0, _utils.base64urlDecode)(credentials.id)
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: undefined
    }));
    callback == null ? void 0 : callback(options);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setPasskeysState({
      loading: false
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}
function* webAuthnPostLogin(_ref12) {
  let {
      payload: {
        callback
      }
    } = _ref12,
    body = (0, _objectWithoutPropertiesLoose2.default)(_ref12.payload, _excluded9);
  try {
    var _publicKey$response$u;
    yield (0, _effects.put)(_reducer.actions.setPasskeysState({
      loading: true
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: true
    }));
    const publicKey = (0, _utils.publicKeyCredentialToJSON)(body.publicKey);
    const _yield$call = yield (0, _effects.call)(_restApi.api.auth.webAuthnPostLoginV2, (0, _extends2.default)({}, publicKey, {
        response: (0, _extends2.default)({}, publicKey.response, {
          userHandle: (_publicKey$response$u = publicKey.response.userHandle) != null ? _publicKey$response$u : undefined
        }),
        recaptchaToken: body.recaptchaToken,
        invitationToken: body.invitationToken
      })),
      {
        user
      } = _yield$call,
      rest = (0, _objectWithoutPropertiesLoose2.default)(_yield$call, _excluded10);
    if ((0, _utils2.isMfaRequired)(user)) {
      const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
      const {
        routes
      } = yield (0, _effects.select)(state => state.auth);
      const mfaRequiredState = yield (0, _mfaRequiredState.getMfaRequiredState)(user);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      if (user.id) {
        localStorage.setItem('userId', user.id);
      }
      yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, (0, _extends2.default)({
        user
      }, rest), {
        isAuthenticated: true
      });
      yield (0, _effects.put)(_reducer.actions.setLoginState({
        error: undefined
      }));
      yield (0, _sagas.afterAuthNavigation)();
      // TODO: Itamar why moving callback to inside the else block
      callback == null ? void 0 : callback(true);
    }
    // callback?.(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  } finally {
    yield (0, _effects.put)(_reducer.actions.setPasskeysState({
      loading: false
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
  }
}
function* postLogin({
  payload
}) {
  const {
    onRedirectTo,
    routes
  } = yield (0, _effects.select)(({
    auth: {
      onRedirectTo,
      routes
    }
  }) => ({
    onRedirectTo,
    routes
  }));
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    const user = yield (0, _effects.call)(_restApi.api.auth.postLogin, payload);
    yield (0, _effects.put)(_reducer.actions.setState({
      user: !!user.accessToken ? user : undefined,
      isAuthenticated: !!user.accessToken
    }));
    yield (0, _sagas.afterAuthNavigation)();
  } catch (e) {
    setTimeout(() => {
      onRedirectTo(routes.authenticatedUrl);
    }, 1000);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces2.LoginStep.loginWithSSOFailed,
      loading: false
    }));
  }
}
function* login({
  payload: {
    email,
    password,
    recaptchaToken,
    invitationToken,
    callback
  }
}) {
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    const {
      user,
      tenants = [],
      activeTenant
    } = yield (0, _effects.call)(_restApi.api.auth.loginv2, {
      email,
      password,
      recaptchaToken,
      invitationToken
    });
    const onRedirectTo = _restApi.ContextHolder.onRedirectTo;
    const {
      routes
    } = yield (0, _effects.select)(state => state.auth);
    if ((0, _utils2.isMfaRequired)(user)) {
      const mfaRequiredState = yield (0, _mfaRequiredState.getMfaRequiredState)(user);
      yield (0, _effects.put)(_reducer.actions.setState(mfaRequiredState));
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      const {
        loginState
      } = yield (0, _effects.select)(state => state.auth);
      const isAuthenticated = !!user.accessToken;
      if (user.id) {
        localStorage.setItem('userId', user.id);
      }
      yield (0, _effects.call)(_saga5.afterAuthenticationStateUpdate, {
        user,
        tenants,
        activeTenant
      }, {
        loginState: {
          flow: loginState.flow,
          quickLoginToRegister: loginState.quickLoginToRegister,
          email,
          loading: false,
          error: undefined,
          mfaToken: user.mfaToken,
          step: loginState.flow === _interfaces2.LoginFlow.Login ? _interfaces2.LoginStep.success : loginState.step,
          tenants,
          tenantsLoading: true,
          isBreachedPassword: user.isBreachedPassword
        },
        isAuthenticated
      });
      const [securityCenterLoginFlows] = yield (0, _effects.call)(_helpers.getFeatureFlags, ['security-center-show-login-flows']);
      if (loginState.flow === _interfaces2.LoginFlow.Login) {
        if (securityCenterLoginFlows && user.isBreachedPassword && !isAuthenticated) {
          yield (0, _effects.put)(_reducer.actions.setLoginState({
            step: _interfaces2.LoginStep.breachedPassword,
            loading: false
          }));
        } else {
          if (isAuthenticated) {
            const shouldShowPrompt = yield (0, _effects.call)(_saga5.shouldShowPromptPasskeys);
            if (shouldShowPrompt) {
              yield (0, _effects.put)(_reducer.actions.setLoginState({
                step: _interfaces2.LoginStep.promptPasskeys,
                loading: false
              }));
              onRedirectTo(routes.loginUrl, {
                preserveQueryParams: true
              });
            } else {
              yield (0, _sagas.afterAuthNavigation)();
            }
          }
        }
      }
    }

    // TODO: extract item name to constants
    localStorage.removeItem('register-quick-login');
    callback == null ? void 0 : callback(true);
  } catch (e) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    callback == null ? void 0 : callback(false, e);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      email,
      error: (0, _utils3.errorHandler)(e),
      loading: false
    }));
  }
}
function* recoverMfa({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    var _payload$callback;
    yield (0, _effects.call)(_restApi.api.auth.recoverMfaToken, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: undefined,
      step: _interfaces2.LoginStep.preLogin
    }));
    yield (0, _effects.put)(_reducer.actions.setState({
      user: undefined,
      isAuthenticated: false
    }));
    (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
  } catch (e) {
    var _payload$callback2;
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      error: (0, _utils3.errorHandler)(e),
      loading: false
    }));
    (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, false, e);
  }
}
function* logout({
  payload
}) {
  const {
    hostedLoginBox
  } = yield (0, _effects.select)(state => state.auth);
  yield (0, _effects.put)(_reducer.actions.setState({
    isLoading: true
  }));
  try {
    if (hostedLoginBox) {
      yield (0, _effects.call)(_restApi.api.auth.OAuthLogout);
    } else {
      yield (0, _effects.call)(_restApi.api.auth.logout);
    }
  } catch {}
  yield (0, _effects.put)(_reducer.actions.resetState());
  yield (0, _effects.put)(_reducer.actions.requestAuthorize(true));
  payload == null ? void 0 : payload();
}
function* silentLogout({
  payload
}) {
  var _payload$callbackTime;
  try {
    yield (0, _effects.call)(_restApi.api.auth.logout);
  } catch {}
  setTimeout(() => {
    var _payload$callback3;
    return payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
  }, (_payload$callbackTime = payload == null ? void 0 : payload.callbackTimeout) != null ? _payload$callbackTime : 500);
}
function* handleEnrollMFAResponse({
  user,
  tenants,
  activeTenant
}) {
  const mfaState = {
    step: _interfaces3.MFAStep.recoveryCode,
    loading: false,
    error: undefined,
    saving: false
  };
  if (user != null && user.recoveryCode) {
    mfaState.recoveryCode = user.recoveryCode;
  }
  yield (0, _effects.put)(_reducer.actions.setMfaState(mfaState));
  yield (0, _effects.put)(_reducer.actions.setUser(user));
  yield (0, _effects.put)(_reducer.actions.setTenantsState({
    tenants,
    activeTenant,
    loading: false
  }));
  if (user.id) {
    localStorage.setItem('userId', user.id);
  }
}
function* preEnrollMFASMSForLogin(_ref13) {
  let {
      payload: {
        callback
      }
    } = _ref13,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref13.payload, _excluded11);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    const data = yield (0, _effects.call)(_restApi.api.auth.preEnrollMFASMSForLogin, payload);
    yield (0, _effects.put)(_reducer.actions.setMfaState({
      otcToken: data.otcToken,
      step: _interfaces3.MFAStep.smsVerifyCode,
      phoneNumber: data.phoneNumber
    }));
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  }
}
function* enrollMFASMSForLogin(_ref14) {
  let {
      payload: {
        callback
      }
    } = _ref14,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref14.payload, _excluded12);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    const data = yield (0, _effects.call)(_restApi.api.auth.enrollMFASMSForLoginV2, payload);
    yield handleEnrollMFAResponse(data);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  }
}
function* preEnrollMFAWebAuthnForLogin(_ref15) {
  let {
      payload: {
        callback
      }
    } = _ref15,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref15.payload, _excluded13);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    var _data$options$exclude;
    const data = yield (0, _effects.call)(_restApi.api.auth.preEnrollMFAWebAuthnForLogin, payload);
    const options = (0, _extends2.default)({}, data.options, {
      challenge: (0, _utils.base64urlDecode)(data.options.challenge),
      user: (0, _extends2.default)({}, data.options.user, {
        id: (0, _utils.base64urlDecode)(data.options.user.id)
      }),
      excludeCredentials: (_data$options$exclude = data.options.excludeCredentials) == null ? void 0 : _data$options$exclude.map(credentials => (0, _extends2.default)({}, credentials, {
        id: (0, _utils.base64urlDecode)(credentials.id)
      }))
    });
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback({
      options,
      webauthnToken: data.webauthnToken
    });
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  }
}
function* enrollMFAWebAuthnForLogin(_ref16) {
  let {
      payload: {
        callback
      }
    } = _ref16,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref16.payload, _excluded14);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    const publicKey = (0, _utils.publicKeyCredentialToJSON)(payload.publicKey);
    const data = yield (0, _effects.call)(_restApi.api.auth.enrollMFAWebAuthnForLoginV2, (0, _extends2.default)({}, payload, {
      options: publicKey
    }));
    yield handleEnrollMFAResponse(data);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  }
}
function* enrollMFAAuthenticatorAppForLogin(_ref17) {
  let {
      payload: {
        callback
      }
    } = _ref17,
    payload = (0, _objectWithoutPropertiesLoose2.default)(_ref17.payload, _excluded15);
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    const data = yield (0, _effects.call)(_restApi.api.auth.enrollMFAAuthenticatorAppForLoginV2, payload);
    yield handleEnrollMFAResponse(data);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false
    }));
    callback == null ? void 0 : callback(true);
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: (0, _utils3.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(null);
  }
}
function* resetBreachedPassword({
  payload
}) {
  yield (0, _effects.put)(_reducer.actions.setLoginState({
    loading: true
  }));
  try {
    yield (0, _effects.call)(_restApi.api.auth.forgotPassword, payload);
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: undefined,
      step: _interfaces2.LoginStep.breachedPasswordSuccess
    }));
    yield (0, _effects.put)(_reducer.actions.setState({
      isAuthenticated: false
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      loading: false,
      error: (0, _utils3.errorHandler)(e)
    }));
  }
}
function* loginSagas() {
  yield (0, _effects.takeLeading)(_reducer.actions.requestAuthorize, requestAuthorize);
  yield (0, _effects.takeLeading)(_reducer.actions.requestAuthorizeSSR, requestAuthorizeSSR);
  yield (0, _effects.takeLeading)(_reducer.actions.requestHostedLoginAuthorize, refreshOrRequestHostedLoginAuthorize);
  yield (0, _effects.takeLeading)(_reducer.actions.requestHostedLoginAuthorizeV2, refreshOrRequestHostedLoginAuthorizeV2);
  yield (0, _effects.takeLeading)(_reducer.actions.handleHostedLoginCallback, handleHostedLoginCallback);
  yield (0, _effects.takeLeading)(_reducer.actions.preLogin, preLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.postLogin, postLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.login, login);
  yield (0, _effects.takeLeading)(_reducer.actions.logout, logout);
  yield (0, _effects.takeLeading)(_reducer.actions.silentLogout, silentLogout);
  yield (0, _effects.takeLeading)(_reducer.actions.loginWithMfa, _sagas.loginWithMfa);
  yield (0, _effects.takeLeading)(_reducer.actions.recoverMfa, recoverMfa);
  yield (0, _effects.takeLeading)(_reducer.actions.quickSmsPasswordlessPreLogin, quickSmsPasswordlessPreLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.changePhoneNumberWithVerification, changePhoneNumberWithVerification);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyChangePhoneNumber, verifyChangePhoneNumber);
  yield (0, _effects.takeLeading)(_reducer.actions.passwordlessPreLogin, passwordlessPreLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.passwordlessPostLogin, passwordlessPostLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyInviteToken, verifyInviteToken);
  yield (0, _effects.takeLeading)(_reducer.actions.webAuthnPrelogin, webAuthnPrelogin);
  yield (0, _effects.takeLeading)(_reducer.actions.webAuthnPostLogin, webAuthnPostLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.webAuthnCreateNewDeviceSession, webAuthnCreateNewDeviceSession);
  yield (0, _effects.takeLeading)(_reducer.actions.webAuthnVerifyNewDeviceSession, webAuthnVerifyNewDeviceSession);
  yield (0, _effects.takeLeading)(_reducer.actions.afterAuthNavigation, _sagas.afterAuthNavigation);
  yield (0, _effects.takeLeading)(_reducer.actions.getUserIP, getUserIP);
  yield (0, _effects.takeLeading)(_reducer.actions.preEnrollMFASMSForLogin, preEnrollMFASMSForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.enrollMFASMSForLogin, enrollMFASMSForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.preEnrollMFAWebAuthnForLogin, preEnrollMFAWebAuthnForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.enrollMFAWebAuthnForLogin, enrollMFAWebAuthnForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.enrollMFAAuthenticatorAppForLogin, enrollMFAAuthenticatorAppForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.preVerifyMFASMSForLogin, _sagas.preVerifyMFASMSForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyMFASMSForLogin, _sagas.verifyMFASMSForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.preVerifyMFAWebAuthnForLogin, _sagas.preVerifyMFAWebAuthnForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyMFAWebAuthnForLogin, _sagas.verifyMFAWebAuthnForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.preVerifyMFAEmailCode, _sagas.preVerifyMFAEmailCodeForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.verifyMFAEmailCode, _sagas.verifyMFAEmailCodeForLogin);
  yield (0, _effects.takeLeading)(_reducer.actions.resetBreachedPassword, resetBreachedPassword);
}
/*********************************
 *  Preview Sagas
 *********************************/

function* requestAuthorizeMock({
  payload: firstTime
}) {
  if (firstTime) {
    yield (0, _effects.put)(_reducer.actions.setState({
      isLoading: true
    }));
  }
  const user = _dummy.userDemo;
  yield (0, _effects.put)(_reducer.actions.loadTenants());
  yield (0, _effects.put)(_reducer.actions.setState({
    user,
    isAuthenticated: true,
    isLoading: false
  }));
}
function* getUserIPMock({
  payload: {
    callback
  }
}) {
  try {
    const {
      ip
    } = _dummy.dummyIps[0];
    yield (0, _effects.put)(_reducer.actions.setState({
      userIp: ip
    }));
    callback == null ? void 0 : callback(true, ip);
  } catch (e) {
    callback == null ? void 0 : callback(false, e);
  }
}
function* loginSagasMock() {
  yield (0, _effects.takeLeading)(_reducer.actions.requestAuthorize, requestAuthorizeMock);
  yield (0, _effects.takeLeading)(_reducer.actions.afterAuthNavigation, _sagas.afterAuthNavigation);
  yield (0, _effects.takeLeading)(_reducer.actions.getUserIP, getUserIPMock);
}