"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAbsoluteUrl = exports.getSearchParamsFromUrl = exports.getSearchParam = exports.getRedirectUrl = exports.getPathAndSearchParamsFromUrl = exports.getNumberOfMfaDevices = exports.getMfaStepForNotEnrolledUsers = exports.getMfaStepForEnrolledUsers = exports.TENANT_ID_PARAM_KEY = void 0;
exports.isEmailPayload = isEmailPayload;
exports.isOauthCallbackRoute = exports.isMfaRequired = void 0;
var _restApi = require("@frontegg/rest-api");
var _interfaces = require("../MfaState/interfaces");
const isAbsoluteUrl = path => {
  try {
    new URL(path);
    return true;
  } catch (e) {
    return false;
  }
};
exports.isAbsoluteUrl = isAbsoluteUrl;
const isValidRedirectUrl = (redirectUrl, allowedRedirectOrigins) => {
  const currentUrl = new URL(window.location.href);
  const redirectURL = new URL(redirectUrl);
  const isSameSite = redirectURL.origin === currentUrl.origin;
  const isOriginInWhiteList = allowedRedirectOrigins.includes(redirectURL.origin);
  return isOriginInWhiteList || isSameSite;
};
const getRedirectUrl = ({
  authenticatedUrl,
  enforceRedirectToSameSite,
  allowedRedirectOrigins,
  includeQueryParam
}) => {
  const currentUrl = new URL(window.location.href);
  let redirectUrl = authenticatedUrl;
  const redirectUrlQueryParam = currentUrl.searchParams.get('redirectUrl');
  if (redirectUrlQueryParam) {
    if (!enforceRedirectToSameSite || !isAbsoluteUrl(redirectUrlQueryParam)) {
      redirectUrl = redirectUrlQueryParam;
    } else {
      if (isValidRedirectUrl(redirectUrlQueryParam, allowedRedirectOrigins)) {
        redirectUrl = redirectUrlQueryParam;
      } else {
        console.warn('The redirect url param is not valid, the origin is a different site');
      }
    }
  } else if (includeQueryParam) {
    redirectUrl += window.location.search;
  }
  return redirectUrl;
};
exports.getRedirectUrl = getRedirectUrl;
const getSearchParamsFromUrl = url => {
  const {
    searchParams
  } = new URL(url);
  const stringifySearchParam = searchParams.toString();
  if (stringifySearchParam) {
    return `?${stringifySearchParam}`;
  }
};
exports.getSearchParamsFromUrl = getSearchParamsFromUrl;
const getPathAndSearchParamsFromUrl = url => {
  const {
    pathname
  } = new URL(url);
  const searchParams = getSearchParamsFromUrl(url);
  if (searchParams) {
    return pathname + searchParams;
  }
  return pathname;
};

/**
 *
 * @param key
 * @returns the value of the param as string or undefined if it does not exist
 */
exports.getPathAndSearchParamsFromUrl = getPathAndSearchParamsFromUrl;
const getSearchParam = key => {
  const params = new URLSearchParams(window.location.search);
  const param = params.get(key);
  return param != null ? param : undefined;
};
exports.getSearchParam = getSearchParam;
const TENANT_ID_PARAM_KEY = 'tenantId';
exports.TENANT_ID_PARAM_KEY = TENANT_ID_PARAM_KEY;
const isMfaRequired = user => {
  if (user.mfaRequired && user.mfaToken) {
    _restApi.ContextHolder.setAccessToken(null);
    _restApi.ContextHolder.setUser(null);
    return true;
  } else {
    _restApi.ContextHolder.setAccessToken(user.accessToken);
    _restApi.ContextHolder.setUser(user);
    return false;
  }
};
exports.isMfaRequired = isMfaRequired;
const getNumberOfMfaDevices = mfaDevices => {
  const numberOfWebAuthnDevices = +Boolean(mfaDevices.webauthn.length);
  const numberOfPhoneDevices = +Boolean(mfaDevices.phones.length);
  const numberOfAuthenticators = +Boolean(mfaDevices.authenticators.length);
  const numberOfEmails = +Boolean(mfaDevices.emails.length);
  const totalDevices = numberOfWebAuthnDevices + numberOfPhoneDevices + numberOfAuthenticators + numberOfEmails;
  return {
    numberOfWebAuthnDevices,
    numberOfPhoneDevices,
    numberOfAuthenticators,
    numberOfEmails,
    totalDevices
  };
};
exports.getNumberOfMfaDevices = getNumberOfMfaDevices;
const getMfaStepForEnrolledUsers = mfaDevices => {
  const {
    numberOfPhoneDevices,
    numberOfAuthenticators,
    numberOfEmails,
    totalDevices
  } = getNumberOfMfaDevices(mfaDevices);
  if (totalDevices === 1) {
    if (numberOfAuthenticators) {
      return _interfaces.MFAStep.authenticatorApp;
    } else if (numberOfPhoneDevices) {
      return _interfaces.MFAStep.smsVerifyCode;
    } else if (numberOfEmails) {
      return _interfaces.MFAStep.emailVerifyCode;
    }
  }
  return _interfaces.MFAStep.verify;
};
exports.getMfaStepForEnrolledUsers = getMfaStepForEnrolledUsers;
const getMfaStepForNotEnrolledUsers = mfaStrategies => {
  if (mfaStrategies.length === 1) {
    const [strategy] = mfaStrategies;
    if (strategy === _restApi.MFAStrategyEnum.AuthenticatorApp) {
      return _interfaces.MFAStep.authenticatorApp;
    } else if (strategy === _restApi.MFAStrategyEnum.SMS) {
      return _interfaces.MFAStep.smsSetPhoneNumber;
    } else if (strategy === _restApi.MFAStrategyEnum.EmailCode) {
      return _interfaces.MFAStep.emailVerifyCode;
    }
  }
  return _interfaces.MFAStep.verify;
};
exports.getMfaStepForNotEnrolledUsers = getMfaStepForNotEnrolledUsers;
const isOauthCallbackRoute = activeUri => {
  return activeUri === '/oauth/callback';
};
exports.isOauthCallbackRoute = isOauthCallbackRoute;
function isEmailPayload(payload) {
  return 'email' in payload;
}