"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loginWithMfa = loginWithMfa;
exports.mfaWithAuthenticator = mfaWithAuthenticator;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _effects = require("redux-saga/effects");
var _restApi = require("@frontegg/rest-api");
var _reducer = require("../../reducer");
var _interfaces = require("../interfaces");
var _saga = require("../saga.utils");
var _afterAuthNavigation = require("./afterAuthNavigation.saga");
var _helpers = require("../../../helpers");
var _utils = require("../../../utils");
const _excluded = ["callback"];
/**
 * @param tenants
 * @param isAuthenticated
 * @param isStepUp
 * @returns additional update object for the afterAuthenticationStateUpdate saga as part of MFA auth with authenticator app
 */
function* buildPostAuthStateUpdate(tenants, isAuthenticated, isStepUp) {
  const {
    loginState
  } = yield (0, _effects.select)(state => state.auth);
  let additionalUpdate = {};
  if (!isStepUp) {
    const step = loginState.flow === _interfaces.LoginFlow.Login ? _interfaces.LoginStep.success : loginState.step;
    additionalUpdate = {
      loginState: {
        flow: loginState.flow,
        quickLoginToRegister: loginState.quickLoginToRegister,
        loading: false,
        step,
        error: undefined,
        tenants
      }
    };
  }
  return (0, _extends2.default)({}, additionalUpdate, {
    isAuthenticated
  });
}

/**
 * Handle after MFA authentication with authenticator app for login
 */
function* postLoginMfaAuthenticator(isAuthenticated, callback) {
  const {
    loginState
  } = yield (0, _effects.select)(state => state.auth);
  if (loginState.flow !== _interfaces.LoginFlow.Login) return;
  const [securityCenterLoginFlows] = yield (0, _effects.call)(_helpers.getFeatureFlags, ['security-center-show-login-flows']);
  if (securityCenterLoginFlows && loginState.isBreachedPassword && !isAuthenticated) {
    yield (0, _effects.put)(_reducer.actions.setLoginState({
      step: _interfaces.LoginStep.breachedPassword,
      loading: false
    }));
  } else {
    const shouldShowPrompt = yield (0, _effects.call)(_saga.shouldShowPromptPasskeys);
    if (shouldShowPrompt) {
      yield (0, _effects.put)(_reducer.actions.setLoginState({
        step: _interfaces.LoginStep.promptPasskeys,
        loading: false
      }));
    } else {
      yield (0, _afterAuthNavigation.afterAuthNavigation)();
    }
  }
  callback == null ? void 0 : callback(true);
}

/**
 * Handle after MFA authentication with authenticator app for step up
 */
function* postStepUpMfaAuthenticator(callback) {
  yield (0, _afterAuthNavigation.afterStepUpAuthNavigation)();
  callback == null ? void 0 : callback(true);
}

/**
 * Utility function to handle MFA authentication with authenticator app
 * @param payload MFA with authenticator action payload
 * @param setLoadingAction set loading action
 * @param isStepUp true if this is a step up authentication
 * @returns
 */
function* mfaWithAuthenticator(_ref, setLoadingAction, isStepUp) {
  let {
      callback
    } = _ref,
    loginWithMfaPayload = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
  yield (0, _effects.put)(setLoadingAction({
    loading: true,
    error: undefined
  }));
  try {
    const {
      user,
      tenants = [],
      activeTenant
    } = yield (0, _effects.call)(_restApi.api.auth.loginWithMfaV2, loginWithMfaPayload);
    const isAuthenticated = !!user.accessToken;
    const additionalUpdate = yield (0, _effects.call)(buildPostAuthStateUpdate, tenants, isAuthenticated, isStepUp);
    yield (0, _effects.call)(_saga.afterAuthenticationStateUpdate, {
      user,
      tenants,
      activeTenant
    }, additionalUpdate);
    if (user.id) {
      localStorage.setItem('userId', user.id);
    }
    yield (0, _effects.put)(setLoadingAction({
      loading: false,
      error: undefined
    }));
    if (isStepUp) {
      yield (0, _effects.call)(postStepUpMfaAuthenticator, callback);
      return;
    }
    yield (0, _effects.call)(postLoginMfaAuthenticator, isAuthenticated, callback);
  } catch (e) {
    yield (0, _effects.put)(setLoadingAction({
      loading: false,
      error: (0, _utils.errorHandler)(e)
    }));
    callback == null ? void 0 : callback(false, e);
  }
}

/**
 * Login with MFA with authenticator app - external saga
 * @param payload.mfaToken
 * @param payload.mfaDevices
 * @param payload.rememberDevice
 * @param payload.invitationToken
 * @param payload.callback - The callback function to be called after the request is done
 */
function* loginWithMfa({
  payload
}) {
  yield mfaWithAuthenticator(payload, _reducer.actions.setLoginState, false);
}