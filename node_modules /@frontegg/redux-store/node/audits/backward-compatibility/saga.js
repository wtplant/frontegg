"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sagas = sagas;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _restApi = require("@frontegg/rest-api");
var _reducer = require("./reducer");
var _effects = require("redux-saga/effects");
const select = () => (0, _effects.select)(_ => _[_reducer.storeName]);
function* loadStats() {
  const {
    sortBy,
    sortDirection
  } = yield select();
  try {
    const stats = yield (0, _effects.call)(_restApi.api.audits.getAuditsStats, {
      sortBy,
      sortDirection,
      count: _reducer.defaultItemsPerPage
    });
    yield (0, _effects.put)(_reducer.actions.loadStatsSuccess(stats));
  } catch (e) {
    const errorMessage = {
      name: 'stats',
      error: e
    };
    console.error('failed to load stats - ', e);
    yield (0, _effects.put)(_reducer.actions.loadItemFailedAction(errorMessage));
  }
}
function* loadMetadata() {
  try {
    const result = yield (0, _effects.call)(_restApi.api.metadata.getAuditsMetadata);
    yield (0, _effects.put)(_reducer.actions.loadMetadataSuccess(result));
  } catch (e) {
    const errorMessage = {
      name: 'metadata',
      error: e
    };
    console.error('failed to load metadata - ', e);
    yield (0, _effects.put)(_reducer.actions.loadItemFailedAction(errorMessage));
  }
}
const filterToObject = arr => arr.reduce((res, curr) => {
  res[curr.key] = curr.value;
  return res;
}, {});
function* loadAuditsFunction({
  payload
}) {
  const {
    filters,
    sortBy,
    sortDirection,
    filter,
    offset,
    virtualScroll
  } = yield select();
  const {
    appendMode = virtualScroll,
    onlyOneLoad = true,
    offset: incomeOffset
  } = payload || {};
  const {
    rowsData
  } = appendMode ? yield select() : {
    rowsData: []
  };
  try {
    const f2o = filterToObject(filters);
    const {
      data,
      total
    } = yield (0, _effects.call)(_restApi.api.audits.getAudits, (0, _extends2.default)({}, virtualScroll && {
      paginationMode: 'virtual'
    }, {
      sortDirection,
      sortBy,
      filter
    }, f2o, {
      // TODO: refactor once api become V2 with query field for virtual scroll
      offset: virtualScroll ? rowsData.length + incomeOffset || rowsData.length + offset : incomeOffset || offset,
      count: _reducer.defaultItemsPerPage
    }));
    yield (0, _effects.put)(_reducer.actions.loadAuditsSuccess({
      rowsData: [...rowsData, ...data],
      total
    }));
    if (onlyOneLoad) {
      yield (0, _effects.put)(_reducer.actions.finishLoading());
    }
  } catch (e) {
    const errorMessage = {
      name: 'audits',
      error: e
    };
    console.error('failed to load audits - ', e);
    yield (0, _effects.put)(_reducer.actions.loadItemFailedAction(errorMessage));
  }
}
function* initDataFunction() {
  yield (0, _effects.put)(_reducer.actions.startLoading());
  yield (0, _effects.all)([loadStats(), loadMetadata(), loadAuditsFunction({
    payload: {
      onlyOneLoad: false
    },
    type: ''
  })]);
  yield (0, _effects.put)(_reducer.actions.finishLoading());
}
function* removeFilterFunction({
  payload
}) {
  const {
    filters: allFilters
  } = yield select();
  const removedFilterIndex = allFilters.findIndex(item => item.key === payload.key);
  if (removedFilterIndex < 0) {
    return;
  }
  const newFilters = [...allFilters.slice(0, removedFilterIndex), ...allFilters.slice(removedFilterIndex + 1)];
  yield (0, _effects.put)(_reducer.actions.setFilterData(newFilters));
}
function* filterDataFunction({
  payload
}) {
  const {
    filters: allFilters
  } = yield select();
  let filterIndex = allFilters.findIndex(item => item.key === payload.key);
  if (filterIndex < 0) {
    filterIndex = allFilters.length;
  }
  const newFilters = [...allFilters.slice(0, filterIndex), payload, ...allFilters.slice(filterIndex + 1)];
  yield (0, _effects.put)(_reducer.actions.setFilterData(newFilters));
}
function* exportCsvFunction() {
  const {
    filters,
    sortBy,
    sortDirection,
    filter,
    headerProps
  } = yield select();
  const f2o = filterToObject(filters);
  yield (0, _effects.put)(_reducer.actions.startDownloadingCsv());
  const outputFileName = `audits.csv`;
  try {
    yield _restApi.api.audits.exportAudits((0, _extends2.default)({
      endpoint: 'csv/v2',
      headerProps,
      sortDirection,
      sortBy,
      filter
    }, f2o, {
      offset: 0,
      outputFileName
    }));
  } catch (e) {
    console.error('failed to export audits - ', e);
  } finally {
    yield (0, _effects.put)(_reducer.actions.stopDownloadingCsv());
  }
}
function* sagas() {
  yield (0, _effects.takeLatest)(_reducer.actions.initData, initDataFunction);
  yield (0, _effects.takeLatest)(_reducer.actions.removeFilter, removeFilterFunction);
  yield (0, _effects.takeLatest)(_reducer.actions.filterData, filterDataFunction);
  yield (0, _effects.takeLatest)([_reducer.actions.loadAudits, _reducer.actions.textSearch, _reducer.actions.onPageChange], loadAuditsFunction);
  yield (0, _effects.takeLatest)([_reducer.actions.setFilterData, _reducer.actions.setDataSorting, _reducer.actions.startRefresh], () => loadAuditsFunction({
    payload: {
      appendMode: false
    },
    type: ''
  }));
  yield (0, _effects.takeLatest)(_reducer.actions.exportCSV, exportCsvFunction);
}