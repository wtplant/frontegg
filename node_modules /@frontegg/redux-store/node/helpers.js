"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRandomString = createRandomString;
exports.generateActionCreator = generateActionCreator;
exports.generateCodeChallenge = generateCodeChallenge;
exports.generateCodeChallengeNative = generateCodeChallengeNative;
exports.generateCodeChallengePureJs = generateCodeChallengePureJs;
exports.getFeatureFlags = getFeatureFlags;
exports.omitProps = omitProps;
exports.readFileAsText = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _restApi = require("@frontegg/rest-api");
var _toolkit = require("@reduxjs/toolkit");
var _effects = require("redux-saga/effects");
var _sha = require("./utils/sha256");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function omitProps(props, keys) {
  const newProps = (0, _extends2.default)({}, props);
  keys.forEach(key => {
    delete newProps[key];
  });
  return newProps;
}
function generateActionCreator(storeName) {
  return (key, withPayload) => withPayload ? (0, _toolkit.createAction)(`${storeName}/${key}`, payload => ({
    payload
  })) : (0, _toolkit.createAction)(`${storeName}/${key}`);
}
async function generateCodeChallengePureJs(codeVerifier) {
  // noinspection TypeScriptValidateJSTypes pure sha256 recevie single params alg name
  const digest = _sha.sha256.digest(new TextEncoder().encode(codeVerifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}
async function generateCodeChallengeNative(codeVerifier) {
  const digest = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}
async function generateCodeChallenge(codeVerifier) {
  var _window$crypto, _window$crypto$subtle;
  // @ts-expect-error Crypto.subtle not available in non-secure domains
  if ((_window$crypto = window.crypto) != null && (_window$crypto$subtle = _window$crypto.subtle) != null && _window$crypto$subtle.digest) {
    return generateCodeChallengeNative(codeVerifier);
  } else {
    console.warn('Generating CodeChallenge in non-secure domain:', window.location.origin);
    return generateCodeChallengePureJs(codeVerifier);
  }
}
function createRandomString(length = 16) {
  let text = '';
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
const readFileAsText = file => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.readAsText(file);
  reader.onload = () => resolve(reader.result);
  reader.onerror = reject;
});
exports.readFileAsText = readFileAsText;
function* getFeatureFlags(flags) {
  const appName = yield (0, _effects.select)(state => state.root.appName);
  return _restApi.FeatureFlags.getFeatureFlags(flags, appName);
}