"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sagas = sagas;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _effects = require("redux-saga/effects");
var _reducer = require("./reducer");
var _consts = require("./consts");
var _restApi = require("@frontegg/rest-api");
var _utils = require("../utils");
const _excluded = ["id"],
  _excluded2 = ["id", "enabled"];
const addApi = ['categories', 'channelMap'];
function* loadPlatformData(ch) {
  return yield (0, _effects.call)(loadFunction, {
    payload: {
      api: ch
    },
    type: ''
  });
}
function* loadDataFunction({
  payload = _consts.channels
}) {
  yield (0, _effects.put)(_reducer.actions.setConnectivityState({
    isLoading: true
  }));
  try {
    // @ts-ignore
    const values = yield (0, _effects.all)([
    // @ts-ignore
    ...payload.map(loadPlatformData),
    // @ts-ignore
    yield loadFunction({
      payload: {
        api: 'categories'
      },
      type: ''
    }),
    // @ts-ignore
    yield function* () {
      // @ts-ignore
      const res = yield (0, _effects.all)(payload.map(function* (ch) {
        // @ts-ignore
        return yield loadFunction({
          payload: {
            api: 'channelMap',
            params: ch
          },
          type: ''
        });
      }));
      return res.reduce((acc, curr, idx) => (0, _extends2.default)({}, acc, {
        [`${payload[idx]}`]: curr
      }), {});
    }()]);
    // @ts-ignore
    const webhooks = yield loadFunction({
      payload: {
        api: 'webhook'
      },
      type: ''
    });
    const data = values.reduce((acc, curr, idx) => payload[idx] ? values[values.length - 1][payload[idx]].length ? (0, _extends2.default)({}, acc, {
      [`${payload[idx]}`]: curr,
      list: [...acc.list, {
        id: idx,
        key: payload[idx],
        events: _consts.channels2Platform[payload[idx]].events(curr),
        active: _consts.channels2Platform[payload[idx]].isActive(curr),
        platform: _consts.channels2Platform[payload[idx]].title,
        image: _consts.channels2Platform[payload[idx]].image
      }]
    }) : acc : (0, _extends2.default)({}, acc, {
      [`${addApi[idx - payload.length]}`]: curr
    }), {
      list: [],
      webhook: webhooks
    });
    yield (0, _effects.put)(_reducer.actions.setConnectivityState((0, _extends2.default)({}, data, {
      error: undefined,
      isSaving: false,
      isLoading: false
    })));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      isLoading: false
    }));
  }
}
function* loadFunction({
  payload: {
    api,
    params
  }
}) {
  try {
    // TODO: [ Refactor Saga ] refactor mapping routes
    // @ts-ignore
    return yield (0, _effects.call)(_consts.type2ApiGet[api], params);
  } catch (e) {
    return undefined;
  }
}
function* loadSlackFunction() {
  try {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      slackChannels: {
        isLoading: true
      }
    }));

    // TODO: [Typescript 4.8] fix @frontegg/rest-api return value
    // @ts-ignore
    const data = yield (0, _effects.call)(_restApi.api.connectivity.getSlackChannels);
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      error: undefined,
      slackChannels: {
        isLoading: false,
        data
      }
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      error: undefined,
      slackChannels: {
        isLoading: false
      }
    }));
  }
}
function* checkNewStatus(platform, data) {
  const {
    connectivity: {
      list
    }
  } = yield (0, _effects.select)();
  const currPlatform = list.find(({
    key
  }) => key === platform);
  if (!currPlatform) return;
  const newActive = _consts.channels2Platform[platform].isActive(data);
  if (newActive === currPlatform.active) return;
  //TODO: double check
  yield (0, _effects.put)(_reducer.actions.setConnectivityState({
    list: list.map(elm => elm.key === platform ? (0, _extends2.default)({}, elm, {
      active: newActive
    }) : elm)
  }));
}
function* postDataFunction({
  payload: {
    platform,
    data,
    callback
  }
}) {
  const {
    processIds
  } = yield (0, _effects.select)(state => state.connectivity);
  try {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      isSaving: true,
      //@ts-ignore
      processIds: platform === 'webhook' ? [data._id, ...processIds] : processIds
    }));
    if (platform === 'slack') {
      yield postSlackData({
        payload: data,
        type: ''
      });
    } else if (['sms', 'email'].includes(platform)) {
      yield postEmailSMSData({
        payload: data,
        type: platform
      });
    } else {
      yield (0, _effects.call)(_consts.type2ApiPost[platform], data);
    }
    if (!['sms', 'email'].includes(platform)) {
      // @ts-ignore
      const newData = yield loadFunction({
        payload: {
          api: platform
        },
        type: ''
      });
      if (platform === 'webhook') {
        newData.id = data._id;
      }
      yield (0, _effects.put)(_reducer.actions.setConnectivityState({
        error: undefined,
        isSaving: false,
        [`${platform}`]: newData,
        processIds: newData.id ? processIds.filter(el => el !== newData.id) : processIds
      }));
      yield checkNewStatus(platform, newData);
      callback == null ? void 0 : callback(true);
    }
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      error: (0, _utils.errorHandler)(e, e.toString()),
      isSaving: false,
      isLoading: false
    }));
  }
}
function* postSlackData({
  payload
}) {
  const {
    connectivity: {
      slack
    }
  } = yield (0, _effects.select)();
  if (!slack) {
    return;
  }
  const {
    slackSubscriptions: stateSlackSubscriptions
  } = slack;
  const {
    slackSubscriptions
  } = payload;
  yield (0, _effects.all)([...slackSubscriptions.reduce((acc, curr) => {
    var _curr$slackEvents$0$c, _curr$slackEvents$0$c2;
    if (!curr.id && curr.slackEvents && (_curr$slackEvents$0$c = curr.slackEvents[0].channelIds) != null && _curr$slackEvents$0$c.length) {
      return [...acc, curr];
    }
    const el = stateSlackSubscriptions == null ? void 0 : stateSlackSubscriptions.find(_ref => {
      let {
          id
        } = _ref,
        props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
      return id === curr.id && JSON.stringify((0, _extends2.default)({
        id
      }, props)) !== JSON.stringify(curr);
    });
    if (el && curr.slackEvents && (_curr$slackEvents$0$c2 = curr.slackEvents[0].channelIds) != null && _curr$slackEvents$0$c2.length) {
      return [...acc, curr];
    }
    return acc;
  }, []).map(function* (el) {
    // @ts-ignore
    return yield (0, _effects.call)(_consts.type2ApiPost.slack, el);
  }), ...slackSubscriptions.reduce((acc, curr) => {
    if (curr.id && !curr.slackEvents[0].channelIds.length) {
      return [...acc, curr];
    }
    return acc;
  }, []).map(function* (el) {
    // @ts-ignore
    return yield (0, _effects.call)(_restApi.api.connectivity.deleteSlackConfiguration, el);
  })
  // clean the old data
  // ...stateSlackSubscriptions
  //   // @ts-ignore
  //   .reduce((acc, curr) => {
  //     const el = slackSubscriptions.find(({ id }) => id === curr.id);
  //     if (!el) {
  //       return [...acc, curr];
  //     }
  //     return acc;
  //   }, [])
  //   // @ts-ignore
  //   .map(function* (el) {
  //     return yield call(api.connectivity.deleteSlackConfiguration, el as Required<ISlackSubscription>);
  //   }),
  ]);
}

function* postEmailSMSData({
  payload,
  type
}) {
  const {
    connectivity
  } = yield (0, _effects.select)();
  const {
    processIds
  } = yield (0, _effects.select)(state => state.connectivity);
  const stateData = connectivity[type];
  if (!stateData) return;
  let actionsResult = [];
  try {
    actionsResult = yield (0, _effects.all)([
    // create new
    ...payload.reduce((acc, curr) => {
      const state = stateData.find(({
        eventKey
      }) => eventKey === curr.eventKey);
      if (!state && curr.subscriptions[0].recipients.filter(el => el).length) {
        return [...acc, curr];
      }
      return acc;
    }, []).map(function* (data) {
      // TODO: [Typescript 4.8] fix @frontegg/rest-api return value
      // @ts-ignore
      return yield (0, _effects.call)(type === 'email' ? _restApi.api.connectivity.postEmailConfiguration : _restApi.api.connectivity.postSMSConfiguration, data);
    }),
    // update exists
    ...payload.reduce((acc, curr) => {
      const state = stateData.find(({
        eventKey
      }) => eventKey === curr.eventKey);
      if (state && JSON.stringify(state) !== JSON.stringify(curr)) {
        return [...acc, curr];
      }
      return acc;
    }, []).map(function* (data) {
      const {
        subscriptions,
        eventKey
      } = data;
      const _subscriptions$ = subscriptions[0],
        {
          id = '',
          enabled
        } = _subscriptions$,
        body = (0, _objectWithoutPropertiesLoose2.default)(_subscriptions$, _excluded2);
      // @ts-ignore
      return yield (0, _effects.all)([
      // @ts-ignore
      yield (0, _effects.call)(type === 'email' ? _restApi.api.connectivity.patchEmailConfiguration : _restApi.api.connectivity.patchSMSConfiguration, {
        eventKey,
        enabled
      }),
      // @ts-ignore
      yield (0, _effects.call)(type === 'email' ? _restApi.api.connectivity.putEmailSubscriptions : _restApi.api.connectivity.putSMSSubscriptions, id, eventKey, (0, _extends2.default)({}, body, {
        enabled
      }))]);
    }),
    // delete record with empty recipients
    ...payload.reduce((acc, curr) => {
      const state = stateData.find(({
        eventKey
      }) => eventKey === curr.eventKey);
      if (state && state.subscriptions[0].recipients.length && !curr.subscriptions[0].recipients.filter(el => !!el).length) {
        return [...acc, curr];
      }
      return acc;
    }, []).map(function* ({
      eventKey,
      subscriptions
    }) {
      return (0, _effects.call)(type === 'email' ? _restApi.api.connectivity.deleteEmailSubscriptions : _restApi.api.connectivity.deleteSMSSubscriptions, eventKey, subscriptions[0].id || '');
    })]);
  } catch {}
  if (actionsResult.length) {
    // @ts-ignore
    const newData = yield loadFunction({
      payload: {
        api: type
      },
      type: ''
    });
    // yield put(connectivityActions.postDataSuccess({ platform: type, data: newData }));
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      error: undefined,
      isSaving: false,
      [`${type}`]: newData,
      processIds: newData.id ? processIds.filter(el => el !== newData.id) : processIds
    }));
    yield checkNewStatus(type, newData);
  } else {
    // yield put(connectivityActions.postDataSuccess({ platform: type, data: stateData }));
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      error: undefined,
      isSaving: false,
      [`${type}`]: stateData,
      processIds: processIds
    }));
  }
}
function* postCodeFunction({
  payload
}) {
  try {
    yield _restApi.api.connectivity.postSlackCode(payload);
  } catch {}
  // yield put(connectivityActions.postCodeSuccess());
  yield (0, _effects.put)(_reducer.actions.setConnectivityState({
    error: undefined,
    isSaving: false
  }));
}
function* loadSlackPermissions() {
  const {
    slackChannels
  } = yield (0, _effects.select)(state => state.connectivity);
  try {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      slackChannels: (0, _extends2.default)({}, slackChannels, {
        isLoadingScope: true
      })
    }));
    const {
      clientId
    } = yield (0, _effects.call)(_restApi.api.connectivity.getSlackScope);
    // yield put(connectivityActions.loadScopeSuccess(clientId));
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      slackChannels: {
        error: undefined,
        clientId,
        isLoadingScope: false,
        isLoading: false
      }
    }));
  } catch {
    // yield put(connectivityActions.loadScopeSuccess(null));
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      slackChannels: {
        error: undefined,
        isLoadingScope: false,
        isLoading: false
      }
    }));
  }
}
function* deleteWebhookConfigFunction({
  payload
}) {
  const {
    callback,
    webhookId
  } = payload;
  const {
    processIds
  } = yield (0, _effects.select)(state => state.connectivity);
  try {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      isSaving: true
    }));
    yield (0, _effects.call)(_restApi.api.connectivity.deleteWebhooksConfiguration, webhookId);
  } catch (e) {
    callback == null ? void 0 : callback(null, (0, _utils.errorHandler)(e));
  }
  // @ts-ignore
  const newData = yield loadFunction({
    payload: {
      api: 'webhook'
    },
    type: ''
  });
  if (newData) {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      error: undefined,
      isSaving: false,
      webhook: newData,
      processIds: newData.id ? processIds.filter(el => el !== newData.id) : processIds
    }));
  }
  callback == null ? void 0 : callback(true);
}
function* postWebhookTestFunction({
  payload
}) {
  try {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      isTesting: true
    }));
    const {
      statusCode,
      body
    } = yield (0, _effects.call)(_restApi.api.connectivity.postWebhookTest, payload);
    if ([201, 200].includes(statusCode)) {
      // yield put(connectivityActions.postWebhookTestSuccess('success', JSON.stringify(body, null, 2)));
      const message = JSON.stringify(body, null, 2);
      yield (0, _effects.put)(_reducer.actions.setConnectivityState({
        isTesting: false,
        testResult: {
          status: 'success',
          message
        }
      }));
    } else {
      // yield put(connectivityActions.postWebhookTestSuccess('failed', body.toString()));
      yield (0, _effects.put)(_reducer.actions.setConnectivityState({
        isTesting: false,
        testResult: {
          status: 'failed'
        }
      }));
    }
  } catch (e) {
    // yield put(connectivityActions.postWebhookTestSuccess('failed', e.toString()));
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      isTesting: false,
      testResult: {
        status: 'failed',
        message: e.toString()
      }
    }));
  }
}
function* postWebhookRetryFunction({
  payload
}) {
  try {
    const {
      statusCode
    } = yield (0, _effects.call)(_restApi.api.connectivity.postWebhookRetry, payload);
    yield (0, _effects.put)(_reducer.actions.postWebhookRetryResult({
      [payload]: {
        isProcess: false,
        success: statusCode === 202
      }
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.postWebhookRetryResult({
      [payload]: {
        isProcess: false,
        success: false
      }
    }));
  }
}
function* loadWebhookLogsFunction({
  payload: {
    id,
    limit,
    offset
  }
}) {
  const {
    webhookLogs
  } = yield (0, _effects.select)(state => state.connectivity);
  try {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      webhookLogs: (0, _extends2.default)({}, webhookLogs, {
        isLoading: true
      })
    }));
    //TODO: Fix types
    //@ts-ignore
    const data = yield (0, _effects.call)(_restApi.api.connectivity.getWebhookLog, id, offset, limit);
    // yield put(connectivityActions.loadWebhookLogsSuccess(data));
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      error: undefined,
      webhookLogs: (0, _extends2.default)({
        isLoading: false
      }, data)
    }));
  } catch (e) {
    yield (0, _effects.put)(_reducer.actions.setConnectivityState({
      error: undefined,
      webhookLogs: {
        isLoading: false
      }
    }));
  }
}
function* sagas() {
  yield (0, _effects.takeEvery)(_reducer.actions.loadDataAction, loadDataFunction);
  yield (0, _effects.takeLatest)(_reducer.actions.loadSlackActions, loadSlackFunction);
  yield (0, _effects.takeEvery)(_reducer.actions.postDataAction, postDataFunction);
  yield (0, _effects.takeEvery)(_reducer.actions.postCodeAction, postCodeFunction);
  yield (0, _effects.takeEvery)(_reducer.actions.loadScope, loadSlackPermissions);
  yield (0, _effects.takeEvery)(_reducer.actions.deleteWebhookConfigAction, deleteWebhookConfigFunction);
  yield (0, _effects.takeEvery)(_reducer.actions.postWebhookTestAction, postWebhookTestFunction);
  yield (0, _effects.takeEvery)(_reducer.actions.postWebhookRetryAction, postWebhookRetryFunction);
  yield (0, _effects.takeLatest)(_reducer.actions.loadWebhookLogsAction, loadWebhookLogsFunction);
}