import _extends from "@babel/runtime/helpers/esm/extends";
import { FeatureFlags } from '@frontegg/rest-api';
import { createAction } from '@reduxjs/toolkit';
import { select } from 'redux-saga/effects';
import { sha256 } from './utils/sha256';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function omitProps(props, keys) {
  const newProps = _extends({}, props);
  keys.forEach(key => {
    delete newProps[key];
  });
  return newProps;
}
export function generateActionCreator(storeName) {
  return (key, withPayload) => withPayload ? createAction(`${storeName}/${key}`, payload => ({
    payload
  })) : createAction(`${storeName}/${key}`);
}
export async function generateCodeChallengePureJs(codeVerifier) {
  // noinspection TypeScriptValidateJSTypes pure sha256 recevie single params alg name
  const digest = sha256.digest(new TextEncoder().encode(codeVerifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}
export async function generateCodeChallengeNative(codeVerifier) {
  const digest = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(codeVerifier));
  return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}
export async function generateCodeChallenge(codeVerifier) {
  var _window$crypto, _window$crypto$subtle;
  // @ts-expect-error Crypto.subtle not available in non-secure domains
  if ((_window$crypto = window.crypto) != null && (_window$crypto$subtle = _window$crypto.subtle) != null && _window$crypto$subtle.digest) {
    return generateCodeChallengeNative(codeVerifier);
  } else {
    console.warn('Generating CodeChallenge in non-secure domain:', window.location.origin);
    return generateCodeChallengePureJs(codeVerifier);
  }
}
export function createRandomString(length = 16) {
  let text = '';
  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
export const readFileAsText = file => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.readAsText(file);
  reader.onload = () => resolve(reader.result);
  reader.onerror = reject;
});
export function* getFeatureFlags(flags) {
  const appName = yield select(state => state.root.appName);
  return FeatureFlags.getFeatureFlags(flags, appName);
}