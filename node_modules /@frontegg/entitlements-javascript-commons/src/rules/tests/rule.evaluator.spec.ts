import { ConditionLogicEnum, Rule, RuleEvaluationResultEnum, TreatmentEnum } from '../types';
import { createRuleEvaluator } from '../rule.evaluator';
import { OperationEnum } from '../../operations/types';

describe('RuleEvaluator', () => {
  it('should return RuleEvaluationResultEnum.Insufficient when conditions are invalid', () => {
    const rule: Rule = {
      treatment: TreatmentEnum.True,
      conditions: [
        {
          attribute: 'test',
          op: 'not supported' as any,
          value: { list: ['test'] },
          negate: false,
        },
      ],
      conditionLogic: ConditionLogicEnum.And,
    };

    const ruleEvaluator = createRuleEvaluator({ rule });
    const result = ruleEvaluator({});

    expect(result).toEqual(RuleEvaluationResultEnum.Insufficient);
  });

  it('should return RuleEvaluationResultEnum.Insufficient when no (valid) condition passes validation', () => {
    const rule: Rule = {
      treatment: TreatmentEnum.True,
      conditions: [
        {
          attribute: 'attribute',
          op: OperationEnum.StartsWith,
          value: { list: ['test'] },
          negate: false,
        },
        {
          attribute: 'attribute',
          op: OperationEnum.Contains,
          value: { list: ['test'] },
          negate: false,
        },
      ],
      conditionLogic: ConditionLogicEnum.And,
    };

    const ruleEvaluator = createRuleEvaluator({ rule });
    const result = ruleEvaluator({ attribute: '1' });

    expect(result).toEqual(RuleEvaluationResultEnum.Insufficient);
  });

  it('should return RuleEvaluationResultEnum.Insufficient when some (valid) conditions pass validation', () => {
    const rule: Rule = {
      treatment: TreatmentEnum.True,
      conditions: [
        {
          attribute: 'attribute',
          op: OperationEnum.StartsWith,
          value: { list: ['test'] },
          negate: false,
        },
        {
          attribute: 'attribute',
          op: OperationEnum.Contains,
          value: { list: ['test'] },
          negate: false,
        },
      ],
      conditionLogic: ConditionLogicEnum.And,
    };

    const ruleEvaluator = createRuleEvaluator({ rule });
    const result = ruleEvaluator({ attribute: 'te' });

    expect(result).toEqual(RuleEvaluationResultEnum.Insufficient);
  });

  it('should return RuleEvaluationResultEnum.Treatable when all (valid) conditions pass validation', () => {
    const rule: Rule = {
      treatment: TreatmentEnum.True,
      conditions: [
        {
          attribute: 'attribute',
          op: OperationEnum.InList,
          value: { list: ['test'] },
          negate: false,
        },
        {
          attribute: 'attribute',
          op: OperationEnum.Contains,
          value: { list: ['test'] },
          negate: false,
        },
      ],
      conditionLogic: ConditionLogicEnum.And,
    };

    const ruleEvaluator = createRuleEvaluator({ rule });
    const result = ruleEvaluator({ attribute: 'test' });

    expect(result).toEqual(RuleEvaluationResultEnum.Treatable);
  });

  it('should return RuleEvaluationResultEnum.Treatable when all (valid) conditions pass validation', () => {
    const rule: Rule = {
      treatment: TreatmentEnum.True,
      conditions: [
        {
          attribute: 'attribute',
          op: OperationEnum.InList,
          value: { list: ['test'] },
          negate: false,
        },
        {
          attribute: 'attribute',
          op: OperationEnum.Contains,
          value: { list: ['not'] },
          negate: true,
        },
        {
          attribute: 'numeric',
          op: OperationEnum.Equal,
          value: { number: 2 },
          negate: false,
        },
      ],
      conditionLogic: ConditionLogicEnum.And,
    };

    const ruleEvaluator = createRuleEvaluator({ rule });
    const result = ruleEvaluator({ attribute: 'test', numeric: 2 });

    expect(result).toEqual(RuleEvaluationResultEnum.Treatable);
  });
});
