import { fc, test } from '@fast-check/jest';
import { isValidDate, sanitizeDateRange, sanitizeDateValue, sanitizeSingleDate } from '../sanitizers';

describe('Date sanitizers', () => {
  it.each([['2021-01-01'], ['2023-10-23T12:09:17.502Z'], [123432443], [new Date()]])(
    'should return sanitized date when value is a string',
    (value) => {
      const sanitizationResult = sanitizeDateValue(value);

      expect(sanitizationResult).toBeDefined();
      expect(sanitizationResult).toEqual(new Date(value));
    },
  );

  it.each([['not a date'], [], {}, [undefined]])('should return invalid date when value is not a date', (value) => {
    const sanitizationResult = sanitizeDateValue(value as any);

    expect(sanitizationResult).toBeDefined();
    expect(isValidDate(sanitizationResult)).toBe(false);
  });

  test.prop([fc.record({ date: fc.date() })], { verbose: true })(
    'should return sanitized when date value exists',
    (value) => {
      const sanitizationResult = sanitizeSingleDate(value);

      expect(sanitizationResult.isSanitized).toBe(true);
      expect(typeof sanitizationResult.sanitizedValue).toBe('object');
      expect(sanitizationResult.sanitizedValue).toEqual({ date: value.date });
    },
  );

  test.prop([fc.object()], { verbose: true })('should fail sanitization when date value does not exist', (value) => {
    const sanitizationResult = sanitizeSingleDate(value);

    expect(sanitizationResult.isSanitized).toBe(false);
    expect(sanitizationResult.sanitizedValue).toBeUndefined();
  });

  test.prop([fc.record({ start: fc.date(), end: fc.date() })], { verbose: true })(
    'should return sanitized when start and end values exist',
    (value) => {
      const sanitizationResult = sanitizeDateRange(value);

      expect(sanitizationResult.isSanitized).toBe(true);
      expect(typeof sanitizationResult.sanitizedValue).toBe('object');
      expect(sanitizationResult.sanitizedValue).toEqual({ start: value.start, end: value.end });
    },
  );

  test.prop([fc.object()], { verbose: true })(
    'should fail sanitization when start and end values do not exist',
    (value) => {
      const sanitizationResult = sanitizeDateRange(value);

      expect(sanitizationResult.isSanitized).toBe(false);
      expect(sanitizationResult.sanitizedValue).toBeUndefined();
    },
  );
});
