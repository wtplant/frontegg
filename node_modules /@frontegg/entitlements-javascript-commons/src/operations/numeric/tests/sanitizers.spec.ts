import { fc, test } from '@fast-check/jest';
import { sanitizeNumericRange, sanitizeSingleNumber } from '../sanitizers';

describe('Numeric sanitizers', () => {
  test.prop([fc.record({ number: fc.integer() })], { verbose: true })('should return sanitized number', (value) => {
    const sanitizationResult = sanitizeSingleNumber(value);

    expect(sanitizationResult.isSanitized).toBe(true);
    expect(typeof sanitizationResult.sanitizedValue?.number).toBe('number');
    expect(sanitizationResult.sanitizedValue).toEqual({ number: value.number });
  });

  test.prop([fc.object()], { verbose: true })(
    'should not return sanitization values when number does not exist in value',
    (value) => {
      const sanitizationResult = sanitizeSingleNumber(value);

      expect(sanitizationResult.isSanitized).toBe(false);
      expect(sanitizationResult.sanitizedValue).toBeUndefined();
    },
  );

  test.prop([fc.record({ start: fc.integer(), end: fc.integer() })], { verbose: true })(
    'should return sanitized range',
    (value) => {
      const sanitizationResult = sanitizeNumericRange(value);

      expect(sanitizationResult.isSanitized).toBe(true);
      expect(typeof sanitizationResult.sanitizedValue?.start).toBe('number');
      expect(typeof sanitizationResult.sanitizedValue?.end).toBe('number');
      expect(sanitizationResult.sanitizedValue).toEqual({ start: value.start, end: value.end });
    },
  );

  test.prop([fc.object()], { verbose: true })(
    'should not return sanitization values when start or end does not exist in value',
    (value) => {
      const sanitizationResult = sanitizeNumericRange(value);

      expect(sanitizationResult.isSanitized).toBe(false);
      expect(sanitizationResult.sanitizedValue).toBeUndefined();
    },
  );
});
