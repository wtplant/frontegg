import { fc, test } from '@fast-check/jest';
import { sanitizeListString, sanitizeSingleString } from '../sanitizers';

describe('String sanitizers', () => {
  test.prop([fc.record({ list: fc.array(fc.string()) })], { verbose: true })(
    'should return sanitized strings list',
    (value) => {
      const sanitizationResult = sanitizeListString(value);

      expect(sanitizationResult.isSanitized).toBe(true);
      expect(sanitizationResult.sanitizedValue?.list).toEqual(value.list);
    },
  );

  test.prop([fc.object()], { verbose: true })(
    'should not return sanitized strings list when list property does not exist',
    (value) => {
      const sanitizationResult = sanitizeListString(value);

      expect(sanitizationResult.isSanitized).toBe(false);
      expect(sanitizationResult.sanitizedValue).toBeUndefined();
    },
  );

  test.prop([fc.record({ string: fc.string() })], { verbose: true })(
    'should sanitized string string property exists',
    (value) => {
      const sanitizationResult = sanitizeSingleString(value);

      expect(sanitizationResult.isSanitized).toBe(true);
      expect(typeof sanitizationResult.sanitizedValue?.string).toEqual('string');
      expect(sanitizationResult.sanitizedValue?.string).toEqual(value.string);
    },
  );

  test.prop([fc.object()], { verbose: true })(
    'should not return sanitized string when string property does not exist',
    (value) => {
      const sanitizationResult = sanitizeSingleString(value);

      expect(sanitizationResult.isSanitized).toBe(false);
      expect(sanitizationResult.sanitizedValue).toBeUndefined();
    },
  );
});
